/**
 * Building Blocks specified in OGC API - Records - Part 1: Core
 * Common components used in the [OGC standard \"OGC API - Records - Part 1: Core\"] (https://docs.ogc.org/DRAFTS/20-004.html).  OGC API - Records - Part 1: Core 1.0 is an OGC Standard. Copyright (c) 2020 Open Geospatial Consortium. To obtain additional rights of use, visit https://www.ogc.org/legal/ .  This document is also available on [OGC](http://schemas.opengis.net/ogcapi/records/part1/1.0/openapi/ogcapi-records-1.yaml).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: pvretano@pvretano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
} from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

import { ExceptionApiModel } from '../model/models'
import { FeatureCollectionGeoJSONApiModel } from '../model/models'
import { RecordGeoJSONApiModel } from '../model/models'

import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'

@Injectable({
  providedIn: 'root',
})
export class DataApiService {
  protected basePath = 'http://localhost'
  public defaultHeaders = new HttpHeaders()
  public configuration = new Configuration()
  public encoder: HttpParameterCodec

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath
      }
      this.configuration.basePath = basePath
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
  }

  private addToHttpParams(
    httpParams: HttpParams,
    value: any,
    key?: string
  ): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value)
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key)
    }
    return httpParams
  }

  private addToHttpParamsRecursive(
    httpParams: HttpParams,
    value?: any,
    key?: string
  ): HttpParams {
    if (value == null) {
      return httpParams
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        ;(value as any[]).forEach(
          (elem) =>
            (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key))
        )
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(
            key,
            (value as Date).toISOString().substr(0, 10)
          )
        } else {
          throw Error('key may not be null if value is Date')
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k
            ))
        )
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value)
    } else {
      throw Error('key may not be null if value is not object or array')
    }
    return httpParams
  }

  /**
   * fetch a single record
   * Fetch the record with id &#x60;recordId&#x60; in the record collection with id &#x60;collectionId&#x60;.  Use content negotiation to request HTML or GeoJSON.
   * @param collectionId local identifier of a collection
   * @param recordId local identifier of a record
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecord(
    collectionId: string,
    recordId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<RecordGeoJSONApiModel>
  public getRecord(
    collectionId: string,
    recordId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<HttpResponse<RecordGeoJSONApiModel>>
  public getRecord(
    collectionId: string,
    recordId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<HttpEvent<RecordGeoJSONApiModel>>
  public getRecord(
    collectionId: string,
    recordId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<any> {
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        'Required parameter collectionId was null or undefined when calling getRecord.'
      )
    }
    if (recordId === null || recordId === undefined) {
      throw new Error(
        'Required parameter recordId was null or undefined when calling getRecord.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/geo+json',
        'text/html',
        'application/atom+xml',
        'application/json',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<RecordGeoJSONApiModel>(
      `${this.configuration.basePath}/collections/${encodeURIComponent(
        String(collectionId)
      )}/items/${encodeURIComponent(String(recordId))}`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * fetch records
   * Fetch records of the record collection with id &#x60;collectionId&#x60;.  Every record in a dataset belongs to a collection. A dataset may consist of multiple record collections. A record collection is often a collection of records of a similar type, based on a common schema.  Use content negotiation to request HTML or GeoJSON.
   * @param collectionId local identifier of a collection
   * @param bbox Only records that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (height or depth):  * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Minimum value, coordinate axis 3 (optional) * Upper right corner, coordinate axis 1 * Upper right corner, coordinate axis 2 * Maximum value, coordinate axis 3 (optional)  The coordinate reference system of the values is WGS 84 long/lat (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter &#x60;bbox-crs&#x60;.  For WGS 84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude.  However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).  If the vertical axis is included, the third and the sixth number are the bottom and the top of the 3-dimensional bounding box.  If a record has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries.
   * @param datetime Either a date-time or an interval, open or closed. Date and time expressions adhere to RFC 3339. Open intervals are expressed using double-dots.  Examples:  * A date-time: \&quot;2018-02-12T23:20:50Z\&quot; * A closed interval: \&quot;2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\&quot; * Open intervals: \&quot;2018-02-12T00:00:00Z/..\&quot; or \&quot;../2018-03-18T12:31:12Z\&quot;  Only records that have a temporal property that intersects the value of &#x60;datetime&#x60; are selected.  It is left to the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties.
   * @param limit The optional limit parameter limits the number of items that are presented in the response document. Only items are counted that are on the first level of the collection in the response document. Nested objects contained within the explicitly requested items shall not be counted.
   * @param q The optional q parameter supports keyword searching.  Only records whose text fields contain one or more of the specified search terms are selected.  The specific set of text keys/fields/properties of a record to which the q operator is applied is up to the description of the server.   Implementations should, however, apply the q operator to the title, description and keywords keys/fields/properties.
   * @param type The optional type parameter supports searching by resource type.  Only records whose type, as indicated by the value of the type core queryable, is equal to one of the listed values shall be selected.
   * @param externalId The optional externalId parameter supports searching by an identifier that was not assigned by the catalogue (i.e. an external identifier). Only records with an external identifer, as indicated by the value of the externalId core queryable array, that is equal to one of the listed values shall be selected.
   * @param sortby
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecords(
    collectionId: string,
    bbox?: Array<number>,
    datetime?: string,
    limit?: number,
    q?: Array<string>,
    type?: Array<string>,
    externalId?: Array<string>,
    sortby?: Array<string>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<FeatureCollectionGeoJSONApiModel>
  public getRecords(
    collectionId: string,
    bbox?: Array<number>,
    datetime?: string,
    limit?: number,
    q?: Array<string>,
    type?: Array<string>,
    externalId?: Array<string>,
    sortby?: Array<string>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<HttpResponse<FeatureCollectionGeoJSONApiModel>>
  public getRecords(
    collectionId: string,
    bbox?: Array<number>,
    datetime?: string,
    limit?: number,
    q?: Array<string>,
    type?: Array<string>,
    externalId?: Array<string>,
    sortby?: Array<string>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<HttpEvent<FeatureCollectionGeoJSONApiModel>>
  public getRecords(
    collectionId: string,
    bbox?: Array<number>,
    datetime?: string,
    limit?: number,
    q?: Array<string>,
    type?: Array<string>,
    externalId?: Array<string>,
    sortby?: Array<string>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?:
        | 'application/geo+json'
        | 'text/html'
        | 'application/atom+xml'
        | 'application/json'
    }
  ): Observable<any> {
    if (collectionId === null || collectionId === undefined) {
      throw new Error(
        'Required parameter collectionId was null or undefined when calling getRecords.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (bbox) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        bbox.join(COLLECTION_FORMATS['csv']),
        'bbox'
      )
    }
    if (datetime !== undefined && datetime !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>datetime,
        'datetime'
      )
    }
    if (limit !== undefined && limit !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>limit,
        'limit'
      )
    }
    if (q) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        q.join(COLLECTION_FORMATS['csv']),
        'q'
      )
    }
    if (type) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        type.join(COLLECTION_FORMATS['csv']),
        'type'
      )
    }
    if (externalId) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        externalId.join(COLLECTION_FORMATS['csv']),
        'externalId'
      )
    }
    if (sortby) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        sortby.join(COLLECTION_FORMATS['csv']),
        'sortby'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/geo+json',
        'text/html',
        'application/atom+xml',
        'application/json',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<FeatureCollectionGeoJSONApiModel>(
      `${this.configuration.basePath}/collections/${encodeURIComponent(
        String(collectionId)
      )}/items`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }
}
