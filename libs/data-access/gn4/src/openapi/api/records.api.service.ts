/**
 * GeoNetwork 4.2.7 OpenAPI Documentation
 *
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

// @ts-ignore
import { AssociatedRecordApiModel } from '../model/associatedRecord.api.model'
// @ts-ignore
import { BatchEditParameterApiModel } from '../model/batchEditParameter.api.model'
// @ts-ignore
import { ExtentDtoApiModel } from '../model/extentDto.api.model'
// @ts-ignore
import { FeatureResponseApiModel } from '../model/featureResponse.api.model'
// @ts-ignore
import { IProcessingReportApiModel } from '../model/iProcessingReport.api.model'
// @ts-ignore
import { Index1403ResponseApiModel } from '../model/index1403Response.api.model'
// @ts-ignore
import { MetadataBatchApproveParameterApiModel } from '../model/metadataBatchApproveParameter.api.model'
// @ts-ignore
import { MetadataBatchSubmitParameterApiModel } from '../model/metadataBatchSubmitParameter.api.model'
// @ts-ignore
import { MetadataCategoryApiModel } from '../model/metadataCategory.api.model'
// @ts-ignore
import { MetadataProcessingReportApiModel } from '../model/metadataProcessingReport.api.model'
// @ts-ignore
import { MetadataResourceApiModel } from '../model/metadataResource.api.model'
// @ts-ignore
import { MetadataStatusParameterApiModel } from '../model/metadataStatusParameter.api.model'
// @ts-ignore
import { PublicationOptionApiModel } from '../model/publicationOption.api.model'
// @ts-ignore
import { RelatedResponseApiModel } from '../model/relatedResponse.api.model'
// @ts-ignore
import { ReportsApiModel } from '../model/reports.api.model'
// @ts-ignore
import { SavedQueryApiModel } from '../model/savedQuery.api.model'
// @ts-ignore
import { SharingParameterApiModel } from '../model/sharingParameter.api.model'
// @ts-ignore
import { SharingResponseApiModel } from '../model/sharingResponse.api.model'
// @ts-ignore
import { SimpleMetadataProcessingReportApiModel } from '../model/simpleMetadataProcessingReport.api.model'
// @ts-ignore
import { SuggestionTypeApiModel } from '../model/suggestionType.api.model'

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'
import { BaseService } from '../api.base.service'

@Injectable({
  providedIn: 'root',
})
export class RecordsApiService extends BaseService {
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration
  ) {
    super(basePath, configuration)
  }

  /**
   * Add element
   * @endpoint put /records/{metadataUuid}/editor/elements
   * @param metadataUuid Record UUID.
   * @param ref Reference of the insertion point.
   * @param name Name of the element to add (with prefix)
   * @param child Use geonet:attribute for attributes or child name.
   * @param displayAttributes Should attributes be shown on the editor snippet?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addElement(
    metadataUuid: string,
    ref: string,
    name: string,
    child?: string,
    displayAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public addElement(
    metadataUuid: string,
    ref: string,
    name: string,
    child?: string,
    displayAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public addElement(
    metadataUuid: string,
    ref: string,
    name: string,
    child?: string,
    displayAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public addElement(
    metadataUuid: string,
    ref: string,
    name: string,
    child?: string,
    displayAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling addElement.'
      )
    }
    if (ref === null || ref === undefined) {
      throw new Error(
        'Required parameter ref was null or undefined when calling addElement.'
      )
    }
    if (name === null || name === undefined) {
      throw new Error(
        'Required parameter name was null or undefined when calling addElement.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>ref,
      'ref'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>name,
      'name'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>child,
      'child'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>displayAttributes,
      'displayAttributes'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/editor/elements`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Reorder element
   * @endpoint put /records/{metadataUuid}/editor/elements/{direction}
   * @param metadataUuid Record UUID.
   * @param ref Reference of the element to move.
   * @param direction Direction
   * @param displayAttributes Should attributes be shown on the editor snippet?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addElement1(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public addElement1(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public addElement1(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public addElement1(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling addElement1.'
      )
    }
    if (ref === null || ref === undefined) {
      throw new Error(
        'Required parameter ref was null or undefined when calling addElement1.'
      )
    }
    if (direction === null || direction === undefined) {
      throw new Error(
        'Required parameter direction was null or undefined when calling addElement1.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>ref,
      'ref'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>displayAttributes,
      'displayAttributes'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/editor/elements/${this.configuration.encodeParam({ name: 'direction', value: direction, in: 'path', style: 'simple', explode: false, dataType: "'up' | 'down'", dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Add samples
   * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
   * @endpoint put /records/samples
   * @param schema Schema identifiers
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addSamples(
    schema: Array<string>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public addSamples(
    schema: Array<string>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public addSamples(
    schema: Array<string>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public addSamples(
    schema: Array<string>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (schema === null || schema === undefined) {
      throw new Error(
        'Required parameter schema was null or undefined when calling addSamples.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (schema) {
      schema.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'schema'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/samples`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add templates
   * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
   * @endpoint put /records/templates
   * @param schema Schema identifiers
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addTemplates(
    schema: Array<string>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public addTemplates(
    schema: Array<string>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public addTemplates(
    schema: Array<string>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public addTemplates(
    schema: Array<string>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (schema === null || schema === undefined) {
      throw new Error(
        'Required parameter schema was null or undefined when calling addTemplates.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (schema) {
      schema.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'schema'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/templates`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Apply a saved query for this metadata
   * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
   * @endpoint post /records/{metadataUuid}/query/{savedQuery}
   * @param metadataUuid The metadata UUID
   * @param savedQuery The saved query to apply
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<{ [key: string]: string }>
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<{ [key: string]: string }>>
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<{ [key: string]: string }>>
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling applyQuery.'
      )
    }
    if (savedQuery === null || savedQuery === undefined) {
      throw new Error(
        'Required parameter savedQuery was null or undefined when calling applyQuery.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/query/${this.configuration.encodeParam({ name: 'savedQuery', value: savedQuery, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<{ [key: string]: string }>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set the records status to approved
   * @endpoint put /records/approve
   * @param metadataBatchApproveParameterApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public approve(
    metadataBatchApproveParameterApiModel: MetadataBatchApproveParameterApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public approve(
    metadataBatchApproveParameterApiModel: MetadataBatchApproveParameterApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public approve(
    metadataBatchApproveParameterApiModel: MetadataBatchApproveParameterApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public approve(
    metadataBatchApproveParameterApiModel: MetadataBatchApproveParameterApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (
      metadataBatchApproveParameterApiModel === null ||
      metadataBatchApproveParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter metadataBatchApproveParameterApiModel was null or undefined when calling approve.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/approve`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: metadataBatchApproveParameterApiModel,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
   * @endpoint put /records/batchediting
   * @param batchEditParameterApiModel
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<IProcessingReportApiModel>
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<IProcessingReportApiModel>>
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<IProcessingReportApiModel>>
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (
      batchEditParameterApiModel === null ||
      batchEditParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter batchEditParameterApiModel was null or undefined when calling batchEdit.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>updateDateStamp,
      'updateDateStamp'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/batchediting`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<IProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: batchEditParameterApiModel,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Cancel edits
   * Cancel current editing session.
   * @endpoint delete /records/{metadataUuid}/editor
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cancelEdits(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public cancelEdits(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public cancelEdits(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public cancelEdits(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling cancelEdits.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/editor`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
   * @endpoint get /records/{metadataUuid}/doi/checkPreConditions
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public checkDoiStatus(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<{ [key: string]: boolean }>
  public checkDoiStatus(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<{ [key: string]: boolean }>>
  public checkDoiStatus(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<{ [key: string]: boolean }>>
  public checkDoiStatus(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling checkDoiStatus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/doi/checkPreConditions`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<{ [key: string]: boolean }>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Check the DOI URL created based on current configuration and pattern.
   * @endpoint get /records/{metadataUuid}/doi/checkDoiUrl
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public checkDoiUrl(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public checkDoiUrl(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public checkDoiUrl(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public checkDoiUrl(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling checkDoiUrl.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'text/plain'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/doi/checkDoiUrl`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Check the status of validation with the INSPIRE service.
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
   * @endpoint get /records/{testId}/validate/inspire
   * @param testId Test identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public checkValidation(
    testId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<{ [key: string]: string }>
  public checkValidation(
    testId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<{ [key: string]: string }>>
  public checkValidation(
    testId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<{ [key: string]: string }>>
  public checkValidation(
    testId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (testId === null || testId === undefined) {
      throw new Error(
        'Required parameter testId was null or undefined when calling checkValidation.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'testId', value: testId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/validate/inspire`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<{ [key: string]: string }>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Clear validation status of one or more records
   * @endpoint delete /records/validate
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/validate`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Close a record task
   * @endpoint put /records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/close
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param closeDate Close date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public closeTask(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    closeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public closeTask(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    closeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public closeTask(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    closeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public closeTask(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    closeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling closeTask.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling closeTask.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling closeTask.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling closeTask.'
      )
    }
    if (closeDate === null || closeDate === undefined) {
      throw new Error(
        'Required parameter closeDate was null or undefined when calling closeTask.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>closeDate,
      'closeDate'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status/${this.configuration.encodeParam({ name: 'statusId', value: statusId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'userId', value: userId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'changeDate', value: changeDate, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/close`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Create a new record
   * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
   * @endpoint put /records/duplicate
   * @param sourceUuid UUID of the source record to copy.
   * @param group The group the record is attached to.
   * @param metadataType The type of record.
   * @param targetUuid Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
   * @param allowEditGroupMembers Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
   * @param category Tags to assign to the record.
   * @param hasCategoryOfSource Copy categories from source?
   * @param isChildOfSource Is child of the record to copy?
   * @param hasAttachmentsOfSource Copy attachments from source?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    allowEditGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    hasAttachmentsOfSource?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    allowEditGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    hasAttachmentsOfSource?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    allowEditGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    hasAttachmentsOfSource?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    allowEditGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    hasAttachmentsOfSource?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (sourceUuid === null || sourceUuid === undefined) {
      throw new Error(
        'Required parameter sourceUuid was null or undefined when calling create.'
      )
    }
    if (group === null || group === undefined) {
      throw new Error(
        'Required parameter group was null or undefined when calling create.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>metadataType,
      'metadataType'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sourceUuid,
      'sourceUuid'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>targetUuid,
      'targetUuid'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>group,
      'group'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>allowEditGroupMembers,
      'allowEditGroupMembers'
    )
    if (category) {
      category.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'category'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>hasCategoryOfSource,
      'hasCategoryOfSource'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>isChildOfSource,
      'isChildOfSource'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>hasAttachmentsOfSource,
      'hasAttachmentsOfSource'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/duplicate`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Submit a record to the Datacite metadata store in order to create a DOI.
   * @endpoint put /records/{metadataUuid}/doi
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createDoi(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<{ [key: string]: string }>
  public createDoi(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<{ [key: string]: string }>>
  public createDoi(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<{ [key: string]: string }>>
  public createDoi(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling createDoi.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/doi`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<{ [key: string]: string }>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete a metadata resource
   * @endpoint delete /records/{metadataUuid}/attachments/{resourceId}
   * @param metadataUuid The metadata UUID
   * @param resourceId The resource identifier (ie. filename)
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public delResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public delResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public delResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public delResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling delResource.'
      )
    }
    if (resourceId === null || resourceId === undefined) {
      throw new Error(
        'Required parameter resourceId was null or undefined when calling delResource.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments/${this.configuration.encodeParam({ name: 'resourceId', value: resourceId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete all uploaded metadata resources
   * @endpoint delete /records/{metadataUuid}/attachments
   * @param metadataUuid The metadata UUID
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public delResources(
    metadataUuid: string,
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public delResources(
    metadataUuid: string,
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public delResources(
    metadataUuid: string,
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public delResources(
    metadataUuid: string,
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling delResources.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete all record status
   * @endpoint delete /records/{metadataUuid}/status
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteAllRecordStatus(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public deleteAllRecordStatus(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public deleteAllRecordStatus(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public deleteAllRecordStatus(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteAllRecordStatus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete attribute
   * @endpoint delete /records/{metadataUuid}/editor/attributes
   * @param metadataUuid Record UUID.
   * @param ref Reference of the attribute to remove.
   * @param displayAttributes Should attributes be shown on the editor snippet?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteAttribute.'
      )
    }
    if (ref === null || ref === undefined) {
      throw new Error(
        'Required parameter ref was null or undefined when calling deleteAttribute.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>ref,
      'ref'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>displayAttributes,
      'displayAttributes'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/editor/attributes`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete element
   * @endpoint delete /records/{metadataUuid}/editor/elements
   * @param metadataUuid Record UUID.
   * @param ref Reference of the element to remove.
   * @param parent Name of the parent.
   * @param displayAttributes Should attributes be shown on the editor snippet?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteElement.'
      )
    }
    if (ref === null || ref === undefined) {
      throw new Error(
        'Required parameter ref was null or undefined when calling deleteElement.'
      )
    }
    if (parent === null || parent === undefined) {
      throw new Error(
        'Required parameter parent was null or undefined when calling deleteElement.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (ref) {
      ref.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'ref'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>parent,
      'parent'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>displayAttributes,
      'displayAttributes'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/editor/elements`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete a record
   * User MUST be able to edit the record to delete it. By default, a backup is made in ZIP format. After that, the record attachments are removed, the document removed from the index and then from the database.
   * @endpoint delete /records/{metadataUuid}
   * @param metadataUuid Record UUID.
   * @param withBackup Backup first the record as MEF in the metadata removed folder.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRecord(
    metadataUuid: string,
    withBackup?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public deleteRecord(
    metadataUuid: string,
    withBackup?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public deleteRecord(
    metadataUuid: string,
    withBackup?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public deleteRecord(
    metadataUuid: string,
    withBackup?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteRecord.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withBackup,
      'withBackup'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete a record status
   * @endpoint delete /records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRecordStatus(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public deleteRecordStatus(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public deleteRecordStatus(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public deleteRecordStatus(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteRecordStatus.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling deleteRecordStatus.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling deleteRecordStatus.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling deleteRecordStatus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status/${this.configuration.encodeParam({ name: 'statusId', value: statusId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'userId', value: userId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'changeDate', value: changeDate, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete one or more records
   * User MUST be able to edit the record to delete it.
   * @endpoint delete /records
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param withBackup Backup first the record as MEF in the metadata removed folder.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withBackup,
      'withBackup'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete tags to one or more records
   * @endpoint delete /records/tags
   * @param id Tag identifier
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling deleteTagForRecords.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    if (id) {
      id.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'id'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/tags`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete tags of a record
   * @endpoint delete /records/{metadataUuid}/tags
   * @param metadataUuid Record UUID.
   * @param id Tag identifier. If none, all tags are removed.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteTags.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (id) {
      id.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'id'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/tags`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Download MEF backup archive
   * The backup contains all metadata not harvested including templates.
   * @endpoint get /records/backups/latest
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public downloadBackup(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/zip'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public downloadBackup(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/zip'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public downloadBackup(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/zip'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public downloadBackup(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/zip'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/zip',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/backups/latest`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * (Experimental) Enable version control
   * @endpoint put /records/{metadataUuid}/versions
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public enableVersionControl(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public enableVersionControl(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public enableVersionControl(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public enableVersionControl(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling enableVersionControl.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/versions`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * (Experimental) Enable version control for one or more records
   * @endpoint put /records/versions
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/versions`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a set of metadata records as CSV
   * The CSV is a short summary of each records.
   * @endpoint get /records/csv
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/csv`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get a set of metadata records as ZIP
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @endpoint get /records/zip
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param format MEF file format.
   * @param withRelated With related records (parent and service).
   * @param withXLinksResolved Resolve XLinks in the records.
   * @param withXLinkAttribute Preserve XLink URLs in the records.
   * @param addSchemaLocation
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>format,
      'format'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withRelated,
      'withRelated'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withXLinksResolved,
      'withXLinksResolved'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withXLinkAttribute,
      'withXLinkAttribute'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>addSchemaLocation,
      'addSchemaLocation'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/zip`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get a set of metadata records as PDF
   * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
   * @endpoint get /records/pdf
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/pdf`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get the list of users \&quot;active\&quot; during a time period.
   * @endpoint get /reports/users
   * @param dateFrom From date of users login date
   * @param dateTo To date of users login date
   * @param groups Group(s) for the users
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getActiveUsers.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getActiveUsers.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateFrom,
      'dateFrom'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateTo,
      'dateTo'
    )
    if (groups) {
      groups.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/reports/users`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get record extents as image
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @endpoint get /records/{metadataUuid}/extents.png
   * @param metadataUuid Record UUID.
   * @param mapsrs (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
   * @param width (optional) width of the image that is created. Only one of width and height are permitted
   * @param height (optional) height of the image that is created. Only one of width and height are permitted
   * @param background (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   * @param fillColor (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   * @param strokeColor (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllRecordExtentAsImage(
    metadataUuid: string,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<string>>
  public getAllRecordExtentAsImage(
    metadataUuid: string,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<string>>>
  public getAllRecordExtentAsImage(
    metadataUuid: string,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<string>>>
  public getAllRecordExtentAsImage(
    metadataUuid: string,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAllRecordExtentAsImage.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>mapsrs,
      'mapsrs'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>width,
      'width'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>height,
      'height'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>background,
      'background'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>fillColor,
      'fillColor'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>strokeColor,
      'strokeColor'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'image/png'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/extents.png`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<string>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get list of record extents
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @endpoint get /records/{metadataUuid}/extents.json
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<ExtentDtoApiModel>>
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<ExtentDtoApiModel>>>
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<ExtentDtoApiModel>>>
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAllRecordExtentAsJson.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/extents.json`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<ExtentDtoApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * List all metadata attachments
   * &lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\&#39;&gt;More info&lt;/a&gt;
   * @endpoint get /records/{metadataUuid}/attachments
   * @param metadataUuid The metadata UUID
   * @param sort Sort by
   * @param approved Use approved version or not
   * @param filter
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<MetadataResourceApiModel>>
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<MetadataResourceApiModel>>>
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<MetadataResourceApiModel>>>
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAllResources.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sort,
      'sort'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>filter,
      'filter'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<MetadataResourceApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
   * .
   * @endpoint get /records
   * @param from Indicates the start position in a sorted list of matches that the client wants to use as the beginning of a page result.
   * @param hitsPerPage Indicates the number of hits per page.
   * @param any Search key
   * @param title A search key for the title.
   * @param facetQ A search facet in the Lucene index. Use the GeoNetwork GUI search to generate the suitable filter values. Example: standard/dcat-ap&amp;createDateYear/2018&amp;sourceCatalog/6d93613e-2b76-4e26-94af-4b4c420a1758 (filter by creation year and source catalog).
   * @param sortBy Lucene sortBy criteria. Relevant values: relevance, title, changeDate.
   * @param sortOrder Sort order. Possible values: reverse.
   * @param similarity Use the Lucene FuzzyQuery. Values range from 0.0 to 1.0 and defaults to 0.8.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAsRdf(
    from?: number,
    hitsPerPage?: number,
    any?: string,
    title?: string,
    facetQ?: string,
    sortBy?: string,
    sortOrder?: string,
    similarity?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getAsRdf(
    from?: number,
    hitsPerPage?: number,
    any?: string,
    title?: string,
    facetQ?: string,
    sortBy?: string,
    sortOrder?: string,
    similarity?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getAsRdf(
    from?: number,
    hitsPerPage?: number,
    any?: string,
    title?: string,
    facetQ?: string,
    sortBy?: string,
    sortOrder?: string,
    similarity?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getAsRdf(
    from?: number,
    hitsPerPage?: number,
    any?: string,
    title?: string,
    facetQ?: string,
    sortBy?: string,
    sortOrder?: string,
    similarity?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>from,
      'from'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>hitsPerPage,
      'hitsPerPage'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>any,
      'any'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>title,
      'title'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>facetQ,
      'facet.q'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sortBy,
      'sortBy'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sortOrder,
      'sortOrder'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>similarity,
      'similarity'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get record related resources
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\&#39;&gt;More info&lt;/a&gt;
   * @endpoint get /records/{metadataUuid}/related
   * @param metadataUuid Record UUID.
   * @param type Type of related resource. If none, all resources are returned.
   * @param approved Use approved version or not
   * @param start Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
   * @param rows Number of rows returned. Default 100.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<RelatedResponseApiModel>
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<RelatedResponseApiModel>>
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<RelatedResponseApiModel>>
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAssociatedResources.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (type) {
      type.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'type'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>start,
      'start'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>rows,
      'rows'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/related`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<RelatedResponseApiModel>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record associated resources
   * Retrieve related services, datasets, sources, ... to this records.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\&#39;&gt;More info&lt;/a&gt;
   * @endpoint get /records/{metadataUuid}/associated
   * @param metadataUuid Record UUID.
   * @param type Type of related resource. If none, all resources are returned.
   * @param approved Use approved version or not
   * @param start Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
   * @param rows Number of rows returned. Default 100.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAssociatedResources1(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<{ [key: string]: Array<AssociatedRecordApiModel> }>
  public getAssociatedResources1(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<
    HttpResponse<{ [key: string]: Array<AssociatedRecordApiModel> }>
  >
  public getAssociatedResources1(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<{ [key: string]: Array<AssociatedRecordApiModel> }>>
  public getAssociatedResources1(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    approved?: boolean,
    start?: number,
    rows?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAssociatedResources1.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (type) {
      type.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'type'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>start,
      'start'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>rows,
      'rows'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/associated`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<{
      [key: string]: Array<AssociatedRecordApiModel>
    }>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Returns a map to decode attributes in a dataset (from the associated feature catalog)
   * @endpoint get /records/{metadataUuid}/featureCatalog
   * @param metadataUuid Record UUID.
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFeatureCatalog(
    metadataUuid: string,
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<FeatureResponseApiModel>
  public getFeatureCatalog(
    metadataUuid: string,
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<FeatureResponseApiModel>>
  public getFeatureCatalog(
    metadataUuid: string,
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<FeatureResponseApiModel>>
  public getFeatureCatalog(
    metadataUuid: string,
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getFeatureCatalog.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/featureCatalog`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<FeatureResponseApiModel>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get one record extent as image
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @endpoint get /records/{metadataUuid}/extents/{geometryIndex}.png
   * @param metadataUuid Record UUID.
   * @param geometryIndex Index of the geometry or bounding box to display. Starts at 1.
   * @param mapsrs (optional) the background map projection. If not passed uses the region/getmap/mapproj setting. If the setting is not set defaults to EPSG:4326
   * @param width (optional) width of the image that is created. Only one of width and height are permitted
   * @param height (optional) height of the image that is created. Only one of width and height are permitted
   * @param background (optional) URL for loading a background image for regions or a key that references the namedBackgrounds (configured in config-spring-geonetwork.xml). A WMS GetMap request is the typical example. The URL must be parameterized with the following parameters: minx, maxx, miny, maxy, width, height
   * @param fillColor (optional) Fill color with format RED,GREEN,BLUE,ALPHA
   * @param strokeColor (optional) Stroke color with format RED,GREEN,BLUE,ALPHA
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getOneRecordExtentAsImage(
    metadataUuid: string,
    geometryIndex: number,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<string>>
  public getOneRecordExtentAsImage(
    metadataUuid: string,
    geometryIndex: number,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<string>>>
  public getOneRecordExtentAsImage(
    metadataUuid: string,
    geometryIndex: number,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<string>>>
  public getOneRecordExtentAsImage(
    metadataUuid: string,
    geometryIndex: number,
    mapsrs?: string,
    width?: number,
    height?: number,
    background?: string,
    fillColor?: string,
    strokeColor?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'image/png'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getOneRecordExtentAsImage.'
      )
    }
    if (geometryIndex === null || geometryIndex === undefined) {
      throw new Error(
        'Required parameter geometryIndex was null or undefined when calling getOneRecordExtentAsImage.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>mapsrs,
      'mapsrs'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>width,
      'width'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>height,
      'height'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>background,
      'background'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>fillColor,
      'fillColor'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>strokeColor,
      'strokeColor'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'image/png'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/extents/${this.configuration.encodeParam({ name: 'geometryIndex', value: geometryIndex, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.png`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<string>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get publication options.
   * @endpoint get /records/sharing/options
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getPublicationOptions(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<PublicationOptionApiModel>>
  public getPublicationOptions(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<PublicationOptionApiModel>>>
  public getPublicationOptions(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<PublicationOptionApiModel>>>
  public getPublicationOptions(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/sharing/options`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<PublicationOptionApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata record
   * Depending on the accept header the appropriate formatter is used. When requesting a ZIP, a MEF version 2 file is returned. When requesting HTML, the default formatter is used.
   * @endpoint get /records/{metadataUuid}
   * @param metadataUuid Record UUID.
   * @param accept Accept header should indicate which is the appropriate format to return. It could be text/html, application/xml, application/zip, ...If no appropriate Accept header found, the XML format is returned.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecord(
    metadataUuid: string,
    accept: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/json'
        | 'text/html'
        | 'application/xml'
        | 'application/xhtml+xml'
        | 'application/pdf'
        | 'application/zip'
        | 'application/x-gn-mef-1-zip'
        | 'application/x-gn-mef-2-zip'
        | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public getRecord(
    metadataUuid: string,
    accept: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/json'
        | 'text/html'
        | 'application/xml'
        | 'application/xhtml+xml'
        | 'application/pdf'
        | 'application/zip'
        | 'application/x-gn-mef-1-zip'
        | 'application/x-gn-mef-2-zip'
        | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public getRecord(
    metadataUuid: string,
    accept: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?:
        | 'application/json'
        | 'text/html'
        | 'application/xml'
        | 'application/xhtml+xml'
        | 'application/pdf'
        | 'application/zip'
        | 'application/x-gn-mef-1-zip'
        | 'application/x-gn-mef-2-zip'
        | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public getRecord(
    metadataUuid: string,
    accept: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?:
        | 'application/json'
        | 'text/html'
        | 'application/xml'
        | 'application/xhtml+xml'
        | 'application/pdf'
        | 'application/zip'
        | 'application/x-gn-mef-1-zip'
        | 'application/x-gn-mef-2-zip'
        | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecord.'
      )
    }
    if (accept === null || accept === undefined) {
      throw new Error(
        'Required parameter accept was null or undefined when calling getRecord.'
      )
    }

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'text/html',
        'application/xml',
        'application/xhtml+xml',
        'application/pdf',
        'application/zip',
        'application/x-gn-mef-1-zip',
        'application/x-gn-mef-2-zip',
        '*/*',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata record as XML or JSON
   * @endpoint get /records/{metadataUuid}/formatters/xml
   * @param metadataUuid Record UUID.
   * @param addSchemaLocation Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param increasePopularity Increase record popularity
   * @param withInfo Add geonet:info details
   * @param attachment Download as a file
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/xml' | 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordAs.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>addSchemaLocation,
      'addSchemaLocation'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>increasePopularity,
      'increasePopularity'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withInfo,
      'withInfo'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>attachment,
      'attachment'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/xml',
        'application/json',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/formatters/xml`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata record as XML or JSON
   * @endpoint get /records/{metadataUuid}/formatters/json
   * @param metadataUuid Record UUID.
   * @param addSchemaLocation Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param increasePopularity Increase record popularity
   * @param withInfo Add geonet:info details
   * @param attachment Download as a file
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordAs1.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>addSchemaLocation,
      'addSchemaLocation'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>increasePopularity,
      'increasePopularity'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withInfo,
      'withInfo'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>attachment,
      'attachment'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/formatters/json`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata record as ZIP
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @endpoint get /records/{metadataUuid}/formatters/zip
   * @param metadataUuid Record UUID.
   * @param format MEF file format.
   * @param withRelated With related records (parent and service).
   * @param withXLinksResolved Resolve XLinks in the records.
   * @param withXLinkAttribute Preserve XLink URLs in the records.
   * @param addSchemaLocation
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordAsZip.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>format,
      'format'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withRelated,
      'withRelated'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withXLinksResolved,
      'withXLinksResolved'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withXLinkAttribute,
      'withXLinkAttribute'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>addSchemaLocation,
      'addSchemaLocation'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/formatters/zip`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get a formatted metadata record
   * @endpoint get /records/{metadataUuid}/formatters/{formatterId}
   * @param formatterId
   * @param metadataUuid Record UUID.
   * @param accept Formatter type to use.
   * @param width
   * @param mdpath
   * @param language Optional language ISO 3 letters code to override HTTP Accept-language header.
   * @param output
   * @param approved Download the approved version
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (formatterId === null || formatterId === undefined) {
      throw new Error(
        'Required parameter formatterId was null or undefined when calling getRecordFormattedBy.'
      )
    }
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordFormattedBy.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>width,
      'width'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>mdpath,
      'mdpath'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>language,
      'language'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>output,
      'output'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/formatters/${this.configuration.encodeParam({ name: 'formatterId', value: formatterId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get metadata record permalink
   * Permalink is by default the landing page formatter but can be configured in the admin console &gt; settings. If the record as a DOI and if enabled in the settings, then it takes priority.
   * @endpoint get /records/{metadataUuid}/permalink
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordPermalink(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public getRecordPermalink(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public getRecordPermalink(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public getRecordPermalink(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordPermalink.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'text/plain'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/permalink`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record popularity
   * @endpoint get /records/{metadataUuid}/popularity
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordPopularity(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public getRecordPopularity(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public getRecordPopularity(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public getRecordPopularity(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordPopularity.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'text/plain'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/popularity`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record sharing settings
   * Return current sharing options for a record.
   * @endpoint get /records/{metadataUuid}/sharing
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordSharingSettings(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SharingResponseApiModel>
  public getRecordSharingSettings(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SharingResponseApiModel>>
  public getRecordSharingSettings(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SharingResponseApiModel>>
  public getRecordSharingSettings(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordSharingSettings.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/sharing`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SharingResponseApiModel>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record status history
   * @endpoint get /records/{metadataUuid}/status
   * @param metadataUuid Record UUID.
   * @param details
   * @param sortOrder Sort direction
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordStatusHistory.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>details,
      'details'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sortOrder,
      'sortOrder'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get record status history by type
   * @endpoint get /records/{metadataUuid}/status/{type}
   * @param metadataUuid Record UUID.
   * @param type Type
   * @param details
   * @param sortOrder Sort direction
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordStatusHistoryByType.'
      )
    }
    if (type === null || type === undefined) {
      throw new Error(
        'Required parameter type was null or undefined when calling getRecordStatusHistoryByType.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>details,
      'details'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sortOrder,
      'sortOrder'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status/${this.configuration.encodeParam({ name: 'type', value: type, in: 'path', style: 'simple', explode: false, dataType: "'workflow' | 'task' | 'event'", dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get record tags
   * Tags are used to classify information.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\&#39;&gt;More info&lt;/a&gt;
   * @endpoint get /records/{metadataUuid}/tags
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordTags(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Set<MetadataCategoryApiModel>>
  public getRecordTags(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Set<MetadataCategoryApiModel>>>
  public getRecordTags(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Set<MetadataCategoryApiModel>>>
  public getRecordTags(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordTags.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/tags`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Set<MetadataCategoryApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get list of metadata file downloads
   * @endpoint get /reports/datadownloads
   * @param dateFrom From date of the metadata downloads
   * @param dateTo To date of the metadata downloads
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportDataDownloads.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportDataDownloads.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateFrom,
      'dateFrom'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateTo,
      'dateTo'
    )
    if (groups) {
      groups.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/reports/datadownloads`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get uploaded files to metadata records during a period.
   * @endpoint get /reports/datauploads
   * @param dateFrom From date of the metadata uploads
   * @param dateTo To date of the metadata uploads
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportDataUploads.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportDataUploads.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateFrom,
      'dateFrom'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateTo,
      'dateTo'
    )
    if (groups) {
      groups.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/reports/datauploads`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get the metadata not published during a period.
   * @endpoint get /reports/metadatainternal
   * @param dateFrom From date of metadata change date
   * @param dateTo To date of metadata change date
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportInternalMetadata.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportInternalMetadata.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateFrom,
      'dateFrom'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateTo,
      'dateTo'
    )
    if (groups) {
      groups.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/reports/metadatainternal`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get the updated metadata during a period.
   * @endpoint get /reports/metadataupdated
   * @param dateFrom From date of metadata change date
   * @param dateTo To date of metadata change date
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportUpdatedMetadata.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportUpdatedMetadata.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateFrom,
      'dateFrom'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateTo,
      'dateTo'
    )
    if (groups) {
      groups.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/reports/metadataupdated`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get a metadata resource
   * @endpoint get /records/{metadataUuid}/attachments/{resourceId}
   * @param metadataUuid The metadata UUID
   * @param resourceId The resource identifier (ie. filename)
   * @param approved Use approved version or not
   * @param size Size (only applies to images). From 1px to 2048px.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getResource.'
      )
    }
    if (resourceId === null || resourceId === undefined) {
      throw new Error(
        'Required parameter resourceId was null or undefined when calling getResource.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>size,
      'size'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments/${this.configuration.encodeParam({ name: 'resourceId', value: resourceId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * List saved queries for this metadata
   * @endpoint get /records/{metadataUuid}/query
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSavedQueries(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<SavedQueryApiModel>>
  public getSavedQueries(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<SavedQueryApiModel>>>
  public getSavedQueries(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<SavedQueryApiModel>>>
  public getSavedQueries(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getSavedQueries.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/query`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<SavedQueryApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record sharing settings
   * @endpoint get /records/sharing
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSharingSettings(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SharingResponseApiModel>
  public getSharingSettings(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SharingResponseApiModel>>
  public getSharingSettings(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SharingResponseApiModel>>
  public getSharingSettings(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/sharing`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SharingResponseApiModel>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get last workflow status for a record
   * @endpoint get /records/{metadataUuid}/status/workflow/last
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getStatus(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getStatus(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getStatus(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getStatus(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getStatus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status/workflow/last`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get suggestions
   * Analyze the record an suggest processes to improve the quality of the record.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\&#39;&gt;More info&lt;/a&gt;
   * @endpoint get /records/{metadataUuid}/processes
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSuggestions(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<SuggestionTypeApiModel>>
  public getSuggestions(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<SuggestionTypeApiModel>>>
  public getSuggestions(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<SuggestionTypeApiModel>>>
  public getSuggestions(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getSuggestions.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/processes`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<SuggestionTypeApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get test suites available.
   * TG13, TG2, ...
   * @endpoint get /records/{metadataUuid}/validate/inspire/testsuites
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getTestSuites(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<{ [key: string]: Array<string> }>
  public getTestSuites(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<{ [key: string]: Array<string> }>>
  public getTestSuites(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<{ [key: string]: Array<string> }>>
  public getTestSuites(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getTestSuites.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/validate/inspire/testsuites`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<{ [key: string]: Array<string> }>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Search status
   * @endpoint get /records/status/search
   * @param type One or more types to retrieve (ie. worflow, event, task). Default is all.
   * @param details All event details including XML changes. Responses are bigger. Default is false
   * @param sortOrder Sort Order (ie. DESC or ASC). Default is none.
   * @param author One or more event author. Default is all.
   * @param owner One or more event owners. Default is all.
   * @param id One or more record identifier. Default is all.
   * @param recordIdentifier One or more metadata record identifier. Default is all.
   * @param uuid One or more metadata uuid. Default is all.
   * @param statusIds One or more status id. Default is all.
   * @param dateFrom Start date
   * @param dateTo End date
   * @param from From page
   * @param size Number of records to return
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    recordIdentifier?: Array<number>,
    uuid?: Array<string>,
    statusIds?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    recordIdentifier?: Array<number>,
    uuid?: Array<string>,
    statusIds?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    recordIdentifier?: Array<number>,
    uuid?: Array<string>,
    statusIds?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    recordIdentifier?: Array<number>,
    uuid?: Array<string>,
    statusIds?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (type) {
      type.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'type'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>details,
      'details'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sortOrder,
      'sortOrder'
    )
    if (author) {
      author.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'author'
        )
      })
    }
    if (owner) {
      owner.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'owner'
        )
      })
    }
    if (id) {
      id.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'id'
        )
      })
    }
    if (recordIdentifier) {
      recordIdentifier.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'recordIdentifier'
        )
      })
    }
    if (uuid) {
      uuid.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuid'
        )
      })
    }
    if (statusIds) {
      statusIds.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'statusIds'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateFrom,
      'dateFrom'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dateTo,
      'dateTo'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>from,
      'from'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>size,
      'size'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/status/search`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Increase record popularity
   * Used when a view is based on the search results content and does not really access the record. Record is then added to the indexing queue and popularity will be updated soon.
   * @endpoint post /records/{metadataUuid}/popularity
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public increaseRecordPopularity(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public increaseRecordPopularity(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public increaseRecordPopularity(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public increaseRecordPopularity(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling increaseRecordPopularity.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'text/plain'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/popularity`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Index a set of records
   * Index a set of records provided either by a bucket or a list of uuids
   * @endpoint get /records/index
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public index1(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Index1403ResponseApiModel>
  public index1(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Index1403ResponseApiModel>>
  public index1(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Index1403ResponseApiModel>>
  public index1(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/index`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Index1403ResponseApiModel>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add a record
   * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
   * @endpoint put /records
   * @param metadataType The type of record.
   * @param url URL of a file to download and insert.
   * @param serverFolder Server folder where to look for files.
   * @param recursiveSearch (Server folder import only) Recursive search in folder.
   * @param publishToAll (XML file only and if workflow is not enabled) Publish record.
   * @param assignToCatalog (MEF file only) Assign to current catalog.
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param category Tags to assign to the record.
   * @param rejectIfInvalid Validate the record first and reject it if not valid.
   * @param transformWith XSL transformation to apply to the record.
   * @param schema Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param allowEditGroupMembers Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
   * @param extra (experimental) Add extra information to the record.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    allowEditGroupMembers?: boolean,
    extra?: string,
    body?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    allowEditGroupMembers?: boolean,
    extra?: string,
    body?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    allowEditGroupMembers?: boolean,
    extra?: string,
    body?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    allowEditGroupMembers?: boolean,
    extra?: string,
    body?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>metadataType,
      'metadataType'
    )
    if (url) {
      url.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'url'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>serverFolder,
      'serverFolder'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>recursiveSearch,
      'recursiveSearch'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>publishToAll,
      'publishToAll'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>assignToCatalog,
      'assignToCatalog'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidProcessing,
      'uuidProcessing'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>group,
      'group'
    )
    if (category) {
      category.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'category'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>rejectIfInvalid,
      'rejectIfInvalid'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformWith,
      'transformWith'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>schema,
      'schema'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>allowEditGroupMembers,
      'allowEditGroupMembers'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>extra,
      'extra'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/xml']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: body,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add a record from XML or MEF/ZIP file
   * Add record in the catalog by uploading files.
   * @endpoint post /records
   * @param metadataType The type of record.
   * @param file XML or MEF file to upload
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param category Tags to assign to the record.
   * @param rejectIfInvalid Validate the record first and reject it if not valid.
   * @param publishToAll (XML file only) Publish record.
   * @param assignToCatalog (MEF file only) Assign to current catalog.
   * @param transformWith XSL transformation to apply to the record.
   * @param schema Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param extra (experimental) Add extra information to the record.
   * @param allowEditGroupMembers Is editable by group members with editor profile? If not, only the author and administrator can edit the record.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    allowEditGroupMembers?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    allowEditGroupMembers?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    allowEditGroupMembers?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    allowEditGroupMembers?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>metadataType,
      'metadataType'
    )
    if (file) {
      file.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'file'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidProcessing,
      'uuidProcessing'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>group,
      'group'
    )
    if (category) {
      category.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'category'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>rejectIfInvalid,
      'rejectIfInvalid'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>publishToAll,
      'publishToAll'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>assignToCatalog,
      'assignToCatalog'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformWith,
      'transformWith'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>schema,
      'schema'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>extra,
      'extra'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>allowEditGroupMembers,
      'allowEditGroupMembers'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add a map metadata record from OGC OWS context
   * Add record in the catalog by uploading a map context.
   * @endpoint post /records/importfrommap
   * @param title A map title
   * @param recordAbstract A map abstract
   * @param xml OGC OWS context as string
   * @param filename OGC OWS context file name
   * @param url OGC OWS context URL
   * @param viewerUrl A map viewer URL to visualize the map
   * @param overview Map overview as PNG (base64 encoded)
   * @param overviewFilename Map overview filename
   * @param topic Topic category
   * @param publishToAll Publish record.
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (title === null || title === undefined) {
      throw new Error(
        'Required parameter title was null or undefined when calling insertOgcMapContextFile.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>title,
      'title'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>recordAbstract,
      'recordAbstract'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>xml,
      'xml'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>filename,
      'filename'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>url,
      'url'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>viewerUrl,
      'viewerUrl'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>overview,
      'overview'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>overviewFilename,
      'overviewFilename'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>topic,
      'topic'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>publishToAll,
      'publishToAll'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidProcessing,
      'uuidProcessing'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>group,
      'group'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/importfrommap`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Update the metadata resource visibility
   * @endpoint patch /records/{metadataUuid}/attachments/{resourceId}
   * @param metadataUuid The metadata UUID
   * @param resourceId The resource identifier (ie. filename)
   * @param visibility The visibility
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataResourceApiModel>
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling patchResource.'
      )
    }
    if (resourceId === null || resourceId === undefined) {
      throw new Error(
        'Required parameter resourceId was null or undefined when calling patchResource.'
      )
    }
    if (visibility === null || visibility === undefined) {
      throw new Error(
        'Required parameter visibility was null or undefined when calling patchResource.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>visibility,
      'visibility'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments/${this.configuration.encodeParam({ name: 'resourceId', value: resourceId, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataResourceApiModel>(
      'patch',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview edits made by XPath expressions.
   * @endpoint post /records/batchediting/preview
   * @param batchEditParameterApiModel
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param diffType Return differences with diff, diffhtml or patch
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewBatchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public previewBatchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public previewBatchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public previewBatchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (
      batchEditParameterApiModel === null ||
      batchEditParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter batchEditParameterApiModel was null or undefined when calling previewBatchEdit.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>diffType,
      'diffType'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/batchediting/preview`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: batchEditParameterApiModel,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Apply a process
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @endpoint post /records/{metadataUuid}/processes/{process}
   * @param metadataUuid Record UUID.
   * @param process Process identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public processRecord(
    metadataUuid: string,
    process: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public processRecord(
    metadataUuid: string,
    process: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public processRecord(
    metadataUuid: string,
    process: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public processRecord(
    metadataUuid: string,
    process: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling processRecord.'
      )
    }
    if (process === null || process === undefined) {
      throw new Error(
        'Required parameter process was null or undefined when calling processRecord.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/processes/${this.configuration.encodeParam({ name: 'process', value: process, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview process result
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @endpoint get /records/{metadataUuid}/processes/{process}
   * @param metadataUuid Record UUID.
   * @param process Process identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling processRecordPreview.'
      )
    }
    if (process === null || process === undefined) {
      throw new Error(
        'Required parameter process was null or undefined when calling processRecordPreview.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/processes/${this.configuration.encodeParam({ name: 'process', value: process, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Publish one or more records
   * See record sharing for more details.
   * @endpoint put /records/publish
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/publish`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: body,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set privileges for ALL group to publish the metadata for all users.
   * @endpoint put /records/{metadataUuid}/publish
   * @param metadataUuid Record UUID.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public publish1(
    metadataUuid: string,
    body?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public publish1(
    metadataUuid: string,
    body?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public publish1(
    metadataUuid: string,
    body?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public publish1(
    metadataUuid: string,
    body?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling publish1.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/publish`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: body,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Create a new resource for a given metadata
   * @endpoint post /records/{metadataUuid}/attachments
   * @param metadataUuid The metadata UUID
   * @param file The file to upload
   * @param visibility The sharing policy
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putResource(
    metadataUuid: string,
    file: Blob,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataResourceApiModel>
  public putResource(
    metadataUuid: string,
    file: Blob,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public putResource(
    metadataUuid: string,
    file: Blob,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public putResource(
    metadataUuid: string,
    file: Blob,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling putResource.'
      )
    }
    if (file === null || file === undefined) {
      throw new Error(
        'Required parameter file was null or undefined when calling putResource.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>visibility,
      'visibility'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['multipart/form-data']

    const canConsumeForm = this.canConsumeForm(consumes)

    let localVarFormParams: { append(param: string, value: any): any }
    let localVarUseForm = false
    let localVarConvertFormParamsToString = false
    // use FormData to transmit files using content-type "multipart/form-data"
    // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
    localVarUseForm = canConsumeForm
    if (localVarUseForm) {
      localVarFormParams = new FormData()
    } else {
      localVarFormParams = new HttpParams({ encoder: this.encoder })
    }

    if (file !== undefined) {
      localVarFormParams =
        (localVarFormParams.append('file', <any>file) as any) ||
        localVarFormParams
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataResourceApiModel>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: localVarConvertFormParamsToString
          ? localVarFormParams.toString()
          : localVarFormParams,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Create a new resource from a URL for a given metadata
   * @endpoint put /records/{metadataUuid}/attachments
   * @param metadataUuid The metadata UUID
   * @param url The URL to load in the store
   * @param visibility The sharing policy
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataResourceApiModel>
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling putResourceFromURL.'
      )
    }
    if (url === null || url === undefined) {
      throw new Error(
        'Required parameter url was null or undefined when calling putResourceFromURL.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>visibility,
      'visibility'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>url,
      'url'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataResourceApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Rate a record
   * User rating of metadata. If the metadata was harvested using the \&#39;GeoNetwork\&#39; protocol and the system setting localrating/enable is false (the default), the user\&#39;s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \&#39;local rating\&#39; is applied, counting only rating from users of this node.&lt;br/&gt;When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
   * @endpoint put /records/{metadataUuid}/rate
   * @param metadataUuid Record UUID.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<number>
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<number>>
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<number>>
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling rateRecord.'
      )
    }
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling rateRecord.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/rate`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<number>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: body,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Restore saved content from a status record
   * @endpoint post /records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/restore
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling restoreAtStatusSave.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling restoreAtStatusSave.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling restoreAtStatusSave.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling restoreAtStatusSave.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status/${this.configuration.encodeParam({ name: 'statusId', value: statusId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'userId', value: userId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'changeDate', value: changeDate, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/restore`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Save edits
   * Save the HTML form content.
   * @endpoint post /records/{metadataUuid}/editor
   * @param metadataUuid Record UUID.
   * @param tab Tab
   * @param withAttributes
   * @param withValidationErrors
   * @param minor
   * @param status Submit for review directly after save.
   * @param commit Save current edits.
   * @param terminate Save and terminate session.
   * @param data Record as XML. TODO: rename xml
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling saveEdits.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>tab,
      'tab'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withAttributes,
      'withAttributes'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withValidationErrors,
      'withValidationErrors'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>minor,
      'minor'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>status,
      'status'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>commit,
      'commit'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>terminate,
      'terminate'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>data,
      'data'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/editor`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Create an overview using the map print module
   * &lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\&#39;&gt;More info&lt;/a&gt;
   * @endpoint put /records/{metadataUuid}/attachments/print-thumbnail
   * @param metadataUuid Record UUID.
   * @param jsonConfig The mapprint module JSON configuration
   * @param rotationAngle The rotation angle of the map
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataResourceApiModel>
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling saveThumbnail.'
      )
    }
    if (jsonConfig === null || jsonConfig === undefined) {
      throw new Error(
        'Required parameter jsonConfig was null or undefined when calling saveThumbnail.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>jsonConfig,
      'jsonConfig'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>rotationAngle,
      'rotationAngle'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/attachments/print-thumbnail`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataResourceApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set group and owner for one or more records
   * @endpoint put /records/ownership
   * @param groupIdentifier Group identifier
   * @param userIdentifier User identifier
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (groupIdentifier === null || groupIdentifier === undefined) {
      throw new Error(
        'Required parameter groupIdentifier was null or undefined when calling setGroupAndOwner.'
      )
    }
    if (userIdentifier === null || userIdentifier === undefined) {
      throw new Error(
        'Required parameter userIdentifier was null or undefined when calling setGroupAndOwner.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>groupIdentifier,
      'groupIdentifier'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>userIdentifier,
      'userIdentifier'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/ownership`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set record group
   * A record is related to one group.
   * @endpoint put /records/{metadataUuid}/group
   * @param metadataUuid Record UUID.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling setRecordGroup.'
      )
    }
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling setRecordGroup.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/group`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: body,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Set record group and owner
   * @endpoint put /records/{metadataUuid}/ownership
   * @param metadataUuid Record UUID.
   * @param groupIdentifier Group identifier
   * @param userIdentifier User identifier
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling setRecordOwnership.'
      )
    }
    if (groupIdentifier === null || groupIdentifier === undefined) {
      throw new Error(
        'Required parameter groupIdentifier was null or undefined when calling setRecordOwnership.'
      )
    }
    if (userIdentifier === null || userIdentifier === undefined) {
      throw new Error(
        'Required parameter userIdentifier was null or undefined when calling setRecordOwnership.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>groupIdentifier,
      'groupIdentifier'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>userIdentifier,
      'userIdentifier'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/ownership`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set the record status
   * @endpoint put /records/{metadataUuid}/status
   * @param metadataUuid Record UUID.
   * @param metadataStatusParameterApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setStatus(
    metadataUuid: string,
    metadataStatusParameterApiModel: MetadataStatusParameterApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<{ [key: string]: string }>
  public setStatus(
    metadataUuid: string,
    metadataStatusParameterApiModel: MetadataStatusParameterApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<{ [key: string]: string }>>
  public setStatus(
    metadataUuid: string,
    metadataStatusParameterApiModel: MetadataStatusParameterApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<{ [key: string]: string }>>
  public setStatus(
    metadataUuid: string,
    metadataStatusParameterApiModel: MetadataStatusParameterApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling setStatus.'
      )
    }
    if (
      metadataStatusParameterApiModel === null ||
      metadataStatusParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter metadataStatusParameterApiModel was null or undefined when calling setStatus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<{ [key: string]: string }>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: metadataStatusParameterApiModel,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set sharing settings for one or more records
   * See record sharing for more details.
   * @endpoint put /records/sharing
   * @param sharingParameterApiModel
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (
      sharingParameterApiModel === null ||
      sharingParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter sharingParameterApiModel was null or undefined when calling share.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/sharing`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: sharingParameterApiModel,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set record sharing
   * Privileges are assigned by group. User needs to be able to edit a record to set sharing settings. For reserved group (ie. Internet, Intranet &amp; Guest), user MUST be reviewer of one group. For other group, if Only set privileges to user\&#39;s groups is set in catalog configuration user MUST be a member of the group.&lt;br/&gt;Clear first allows to unset all operations first before setting the new ones.Clear option does not remove reserved groups operation if user is not an administrator, a reviewer or the owner of the record.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/publishing/managing-privileges.html\&#39;&gt;More info&lt;/a&gt;
   * @endpoint put /records/{metadataUuid}/sharing
   * @param metadataUuid Record UUID.
   * @param sharingParameterApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public share1(
    metadataUuid: string,
    sharingParameterApiModel: SharingParameterApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public share1(
    metadataUuid: string,
    sharingParameterApiModel: SharingParameterApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public share1(
    metadataUuid: string,
    sharingParameterApiModel: SharingParameterApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public share1(
    metadataUuid: string,
    sharingParameterApiModel: SharingParameterApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling share1.'
      )
    }
    if (
      sharingParameterApiModel === null ||
      sharingParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter sharingParameterApiModel was null or undefined when calling share1.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/sharing`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: sharingParameterApiModel,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get saved content from the status record after changes
   * @endpoint get /records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/after
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling showStatusAfter.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling showStatusAfter.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling showStatusAfter.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling showStatusAfter.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status/${this.configuration.encodeParam({ name: 'statusId', value: statusId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'userId', value: userId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'changeDate', value: changeDate, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/after`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get saved content from the status record before changes
   * @endpoint get /records/{metadataUuid}/status/{statusId}.{userId}.{changeDate}/before
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling showStatusBefore.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling showStatusBefore.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling showStatusBefore.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling showStatusBefore.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/status/${this.configuration.encodeParam({ name: 'statusId', value: statusId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'userId', value: userId, in: 'path', style: 'simple', explode: false, dataType: 'number', dataFormat: 'int32' })}.${this.configuration.encodeParam({ name: 'changeDate', value: changeDate, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/before`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Edit a record
   * Return HTML form for editing.
   * @endpoint get /records/{metadataUuid}/editor
   * @param metadataUuid Record UUID.
   * @param currTab Tab
   * @param withAttributes
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public startEditing(
    metadataUuid: string,
    currTab?: string,
    withAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public startEditing(
    metadataUuid: string,
    currTab?: string,
    withAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public startEditing(
    metadataUuid: string,
    currTab?: string,
    withAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public startEditing(
    metadataUuid: string,
    currTab?: string,
    withAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling startEditing.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>currTab,
      'currTab'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>withAttributes,
      'withAttributes'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/editor`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Set the records status to submitted
   * @endpoint put /records/submit
   * @param metadataBatchSubmitParameterApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public submit(
    metadataBatchSubmitParameterApiModel: MetadataBatchSubmitParameterApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public submit(
    metadataBatchSubmitParameterApiModel: MetadataBatchSubmitParameterApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public submit(
    metadataBatchSubmitParameterApiModel: MetadataBatchSubmitParameterApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public submit(
    metadataBatchSubmitParameterApiModel: MetadataBatchSubmitParameterApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (
      metadataBatchSubmitParameterApiModel === null ||
      metadataBatchSubmitParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter metadataBatchSubmitParameterApiModel was null or undefined when calling submit.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/submit`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: metadataBatchSubmitParameterApiModel,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add tags to a record
   * @endpoint put /records/{metadataUuid}/tags
   * @param metadataUuid Record UUID.
   * @param id Tag identifier
   * @param clear Clear all before adding new ones
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling tagRecord.'
      )
    }
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling tagRecord.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (id) {
      id.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'id'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>clear,
      'clear'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/tags`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Add or remove tags to one or more records
   * @endpoint put /records/tags
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param id Tag identifier
   * @param removeId Tag identifier to remove.
   * @param clear Clear all before adding new ones
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    if (id) {
      id.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'id'
        )
      })
    }
    if (removeId) {
      removeId.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'removeId'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>clear,
      'clear'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/tags`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Trigger MEF backup archive
   * The backup contains all metadata not harvested including templates.
   * @endpoint put /records/backups
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public trigger(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public trigger(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public trigger(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public trigger(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/backups`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Un-publish one or more records
   * See record sharing for more details.
   * @endpoint put /records/unpublish
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataProcessingReportApiModel>
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    body?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/unpublish`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: body,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Unsets privileges for ALL group to publish the metadata for all users.
   * @endpoint put /records/{metadataUuid}/unpublish
   * @param metadataUuid Record UUID.
   * @param body
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unpublish1(
    metadataUuid: string,
    body?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public unpublish1(
    metadataUuid: string,
    body?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public unpublish1(
    metadataUuid: string,
    body?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public unpublish1(
    metadataUuid: string,
    body?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling unpublish1.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/unpublish`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: body,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
   * @endpoint delete /records/{metadataUuid}/doi
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unregisterDoi(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public unregisterDoi(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public unregisterDoi(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public unregisterDoi(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling unregisterDoi.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/doi`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Validate a record
   * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
   * @endpoint put /records/{metadataUuid}/validate/internal
   * @param metadataUuid Record UUID.
   * @param isvalid Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<ReportsApiModel>
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<ReportsApiModel>>
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<ReportsApiModel>>
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling validateRecord.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>isvalid,
      'isvalid'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/validate/internal`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<ReportsApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Submit a record to the INSPIRE service for validation.
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
   * @endpoint put /records/{metadataUuid}/validate/inspire
   * @param metadataUuid Record UUID.
   * @param testsuite Test suite to run
   * @param mode Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/plain'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling validateRecordForInspire.'
      )
    }
    if (testsuite === null || testsuite === undefined) {
      throw new Error(
        'Required parameter testsuite was null or undefined when calling validateRecordForInspire.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>testsuite,
      'testsuite'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>mode,
      'mode'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'text/plain'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/${this.configuration.encodeParam({ name: 'metadataUuid', value: metadataUuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}/validate/inspire`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Validate one or more records
   * Update validation status for all records.
   * @endpoint put /records/validate
   * @param uuids Record UUIDs. If null current selection is used.
   * @param approved Use approved version or not
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>approved,
      'approved'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/validate`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Validate one or more records in INSPIRE validator
   * Update validation status for all records.
   * @endpoint put /records/validate/inspire
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param mode Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>mode,
      'mode'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/records/validate/inspire`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }
}
