/**
 * GeoNetwork 4.0.3 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.0.3
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
} from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

import { BatchEditParameterApiModel } from '../model/models'
import { ElementApiModel } from '../model/models'
import { ExtentDtoApiModel } from '../model/models'
import { FeatureResponseApiModel } from '../model/models'
import { IProcessingReportApiModel } from '../model/models'
import { InlineObject1ApiModel } from '../model/models'
import { MetadataCategoryApiModel } from '../model/models'
import { MetadataProcessingReportApiModel } from '../model/models'
import { MetadataResourceApiModel } from '../model/models'
import { MetadataStatusResponseApiModel } from '../model/models'
import { MetadataWorkflowStatusResponseApiModel } from '../model/models'
import { RelatedResponseApiModel } from '../model/models'
import { ReportsApiModel } from '../model/models'
import { SavedQueryApiModel } from '../model/models'
import { SharingParameterApiModel } from '../model/models'
import { SharingResponseApiModel } from '../model/models'
import { SimpleMetadataProcessingReportApiModel } from '../model/models'
import { SuggestionTypeApiModel } from '../model/models'

import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'

@Injectable({
  providedIn: 'root',
})
export class RecordsApiService {
  protected basePath = 'https://apps.titellus.net/geonetwork/srv/api'
  public defaultHeaders = new HttpHeaders()
  public configuration = new Configuration()
  public encoder: HttpParameterCodec

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath
      }
      this.configuration.basePath = basePath
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
  }

  private addToHttpParams(
    httpParams: HttpParams,
    value: any,
    key?: string
  ): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value)
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key)
    }
    return httpParams
  }

  private addToHttpParamsRecursive(
    httpParams: HttpParams,
    value?: any,
    key?: string
  ): HttpParams {
    if (value == null) {
      return httpParams
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        ;(value as any[]).forEach(
          (elem) =>
            (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key))
        )
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(
            key,
            (value as Date).toISOString().substr(0, 10)
          )
        } else {
          throw Error('key may not be null if value is Date')
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k
            ))
        )
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value)
    } else {
      throw Error('key may not be null if value is not object or array')
    }
    return httpParams
  }

  /**
   * Reorder element
   * @param metadataUuid Record UUID.
   * @param ref Reference of the element to move.
   * @param direction Direction
   * @param displayAttributes Should attributes be shown on the editor snippet?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addElement(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public addElement(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public addElement(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public addElement(
    metadataUuid: string,
    ref: string,
    direction: 'up' | 'down',
    displayAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling addElement.'
      )
    }
    if (ref === null || ref === undefined) {
      throw new Error(
        'Required parameter ref was null or undefined when calling addElement.'
      )
    }
    if (direction === null || direction === undefined) {
      throw new Error(
        'Required parameter direction was null or undefined when calling addElement.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (ref !== undefined && ref !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>ref, 'ref')
    }
    if (displayAttributes !== undefined && displayAttributes !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>displayAttributes,
        'displayAttributes'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/editor/elements/${encodeURIComponent(String(direction))}`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add samples
   * Add sample records for one or more schemas. Samples are defined for each standard in the samples folder as MEF files.
   * @param schema Schema identifiers
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addSamples(
    schema: Array<string>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public addSamples(
    schema: Array<string>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public addSamples(
    schema: Array<string>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public addSamples(
    schema: Array<string>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (schema === null || schema === undefined) {
      throw new Error(
        'Required parameter schema was null or undefined when calling addSamples.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (schema) {
      schema.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'schema'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/samples`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add templates
   * Add template records for one or more schemas. Templates are defined for each standard in the template folder as XML files. Template may also contains subtemplates.
   * @param schema Schema identifiers
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public addTemplates(
    schema: Array<string>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public addTemplates(
    schema: Array<string>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public addTemplates(
    schema: Array<string>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public addTemplates(
    schema: Array<string>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (schema === null || schema === undefined) {
      throw new Error(
        'Required parameter schema was null or undefined when calling addTemplates.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (schema) {
      schema.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'schema'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/templates`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Apply a saved query for this metadata
   * All parameters will be substituted to the XPath query. eg. {{protocol}} in the XPath expression will be replaced by the protocol parameter provided in the request body.
   * @param metadataUuid The metadata UUID
   * @param savedQuery The saved query to apply
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<{ [key: string]: string }>
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<{ [key: string]: string }>>
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<{ [key: string]: string }>>
  public applyQuery(
    metadataUuid: string,
    savedQuery: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling applyQuery.'
      )
    }
    if (savedQuery === null || savedQuery === undefined) {
      throw new Error(
        'Required parameter savedQuery was null or undefined when calling applyQuery.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<{ [key: string]: string }>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/query/${encodeURIComponent(String(savedQuery))}`,
      null,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Edit a set of records by XPath expressions. This operations applies the update-fixed-info.xsl transformation for the metadata schema and updates the change date if the parameter updateDateStamp is set to true.
   * @param batchEditParameterApiModel
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<IProcessingReportApiModel>
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<IProcessingReportApiModel>>
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<IProcessingReportApiModel>>
  public batchEdit(
    batchEditParameterApiModel: Array<BatchEditParameterApiModel>,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (
      batchEditParameterApiModel === null ||
      batchEditParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter batchEditParameterApiModel was null or undefined when calling batchEdit.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (updateDateStamp !== undefined && updateDateStamp !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>updateDateStamp,
        'updateDateStamp'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<IProcessingReportApiModel>(
      `${this.configuration.basePath}/records/batchediting`,
      batchEditParameterApiModel,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Cancel edits
   * Cancel current editing session.
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cancelEdits(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public cancelEdits(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public cancelEdits(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public cancelEdits(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling cancelEdits.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/editor`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Check that a record can be submitted to DataCite for DOI creation. DataCite requires some fields to be populated.
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public checkDoiStatus(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<{ [key: string]: boolean }>
  public checkDoiStatus(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<{ [key: string]: boolean }>>
  public checkDoiStatus(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<{ [key: string]: boolean }>>
  public checkDoiStatus(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling checkDoiStatus.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<{ [key: string]: boolean }>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/doi/checkPreConditions`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Check the status of validation with the INSPIRE service.
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. If the process is complete an object with status is returned.
   * @param testId Test identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public checkValidation(
    testId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<{ [key: string]: string }>
  public checkValidation(
    testId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<{ [key: string]: string }>>
  public checkValidation(
    testId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<{ [key: string]: string }>>
  public checkValidation(
    testId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (testId === null || testId === undefined) {
      throw new Error(
        'Required parameter testId was null or undefined when calling checkValidation.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<{ [key: string]: string }>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(testId)
      )}/validate/inspire`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Clear validation status of one or more records
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public cleanValidationStatus(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/validate`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Create a new record
   * Create a record from a template or by copying an existing record.Return the UUID of the newly created record. Existing links in the source record are preserved, this means that the new record may contains link to the source attachments. They need to be manually updated after creation.
   * @param sourceUuid UUID of the source record to copy.
   * @param group The group the record is attached to.
   * @param metadataType The type of record.
   * @param targetUuid Assign a custom UUID. If this UUID already exist an error is returned. This is enabled only if metadata create / generate UUID settings is activated.
   * @param isVisibleByAllGroupMembers Is published to all user group members? If not, only the author and administrator can edit the record.
   * @param category Tags to assign to the record.
   * @param hasCategoryOfSource Copy categories from source?
   * @param isChildOfSource Is child of the record to copy?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    isVisibleByAllGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<string>
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    isVisibleByAllGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<string>>
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    isVisibleByAllGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<string>>
  public create(
    sourceUuid: string,
    group: string,
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    targetUuid?: string,
    isVisibleByAllGroupMembers?: boolean,
    category?: Array<string>,
    hasCategoryOfSource?: boolean,
    isChildOfSource?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (sourceUuid === null || sourceUuid === undefined) {
      throw new Error(
        'Required parameter sourceUuid was null or undefined when calling create.'
      )
    }
    if (group === null || group === undefined) {
      throw new Error(
        'Required parameter group was null or undefined when calling create.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (metadataType !== undefined && metadataType !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>metadataType,
        'metadataType'
      )
    }
    if (sourceUuid !== undefined && sourceUuid !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>sourceUuid,
        'sourceUuid'
      )
    }
    if (targetUuid !== undefined && targetUuid !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>targetUuid,
        'targetUuid'
      )
    }
    if (group !== undefined && group !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>group,
        'group'
      )
    }
    if (
      isVisibleByAllGroupMembers !== undefined &&
      isVisibleByAllGroupMembers !== null
    ) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>isVisibleByAllGroupMembers,
        'isVisibleByAllGroupMembers'
      )
    }
    if (category) {
      category.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'category'
        )
      })
    }
    if (hasCategoryOfSource !== undefined && hasCategoryOfSource !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>hasCategoryOfSource,
        'hasCategoryOfSource'
      )
    }
    if (isChildOfSource !== undefined && isChildOfSource !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>isChildOfSource,
        'isChildOfSource'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<string>(
      `${this.configuration.basePath}/records/duplicate`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Submit a record to the Datacite metadata store in order to create a DOI.
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createDoi(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<{ [key: string]: string }>
  public createDoi(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<{ [key: string]: string }>>
  public createDoi(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<{ [key: string]: string }>>
  public createDoi(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling createDoi.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<{ [key: string]: string }>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/doi`,
      null,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete attribute
   * @param metadataUuid Record UUID.
   * @param ref Reference of the attribute to remove.
   * @param displayAttributes Should attributes be shown on the editor snippet?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public deleteAttribute(
    metadataUuid: string,
    ref: string,
    displayAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteAttribute.'
      )
    }
    if (ref === null || ref === undefined) {
      throw new Error(
        'Required parameter ref was null or undefined when calling deleteAttribute.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (ref !== undefined && ref !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>ref, 'ref')
    }
    if (displayAttributes !== undefined && displayAttributes !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>displayAttributes,
        'displayAttributes'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/editor/attributes`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete element
   * @param metadataUuid Record UUID.
   * @param ref Reference of the element to remove.
   * @param parent Name of the parent.
   * @param displayAttributes Should attributes be shown on the editor snippet?
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public deleteElement(
    metadataUuid: string,
    ref: Array<string>,
    parent: string,
    displayAttributes?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteElement.'
      )
    }
    if (ref === null || ref === undefined) {
      throw new Error(
        'Required parameter ref was null or undefined when calling deleteElement.'
      )
    }
    if (parent === null || parent === undefined) {
      throw new Error(
        'Required parameter parent was null or undefined when calling deleteElement.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (ref) {
      ref.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'ref'
        )
      })
    }
    if (parent !== undefined && parent !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>parent,
        'parent'
      )
    }
    if (displayAttributes !== undefined && displayAttributes !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>displayAttributes,
        'displayAttributes'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/editor/elements`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete one or more records
   * User MUST be able to edit the record to delete it.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param withBackup Backup first the record as MEF in the metadata removed folder.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public deleteRecords(
    uuids?: Array<string>,
    bucket?: string,
    withBackup?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (withBackup !== undefined && withBackup !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withBackup,
        'withBackup'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete tags to one or more records
   * @param id Tag identifier
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<MetadataProcessingReportApiModel>
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public deleteTagForRecords(
    id: Array<number>,
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling deleteTagForRecords.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (id) {
      id.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'id'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/tags`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Delete tags of a record
   * @param metadataUuid Record UUID.
   * @param id Tag identifier. If none, all tags are removed.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public deleteTags(
    metadataUuid: string,
    id?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling deleteTags.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (id) {
      id.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'id'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/tags`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Download MEF backup archive
   * The backup contains all metadata not harvested including templates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public downloadBackup(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/zip' }
  ): Observable<any>
  public downloadBackup(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/zip' }
  ): Observable<HttpResponse<any>>
  public downloadBackup(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/zip' }
  ): Observable<HttpEvent<any>>
  public downloadBackup(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/zip' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/zip',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/records/backups/latest`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * (Experimental) Enable version control
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public enableVersionControl(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<string>
  public enableVersionControl(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<string>>
  public enableVersionControl(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<string>>
  public enableVersionControl(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling enableVersionControl.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<string>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/versions`,
      null,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * (Experimental) Enable version control for one or more records
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<MetadataProcessingReportApiModel>
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public enableVersionControlForRecords(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/versions`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a set of metadata records as CSV
   * The CSV is a short summary of each records.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public exportAsCsv(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/records/csv`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a set of metadata records as ZIP
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param format MEF file format.
   * @param withRelated With related records (parent and service).
   * @param withXLinksResolved Resolve XLinks in the records.
   * @param withXLinkAttribute Preserve XLink URLs in the records.
   * @param addSchemaLocation
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public exportAsMef(
    uuids?: Array<string>,
    bucket?: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (format !== undefined && format !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>format,
        'format'
      )
    }
    if (withRelated !== undefined && withRelated !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withRelated,
        'withRelated'
      )
    }
    if (withXLinksResolved !== undefined && withXLinksResolved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withXLinksResolved,
        'withXLinksResolved'
      )
    }
    if (withXLinkAttribute !== undefined && withXLinkAttribute !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withXLinkAttribute,
        'withXLinkAttribute'
      )
    }
    if (addSchemaLocation !== undefined && addSchemaLocation !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>addSchemaLocation,
        'addSchemaLocation'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      headers = headers.set('Accept', String(accept))
    }

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/records/zip`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a set of metadata records as PDF
   * The PDF is a short summary of each records with links to the complete metadata record in different format (ie. landing page on the portal, XML)
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public exportAsPdf(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/records/pdf`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get the list of users \&quot;active\&quot; during a time period.
   * @param dateFrom From date of users login date
   * @param dateTo To date of users login date
   * @param groups Group(s) for the users
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getActiveUsers(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getActiveUsers.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getActiveUsers.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (dateFrom !== undefined && dateFrom !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateFrom,
        'dateFrom'
      )
    }
    if (dateTo !== undefined && dateTo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateTo,
        'dateTo'
      )
    }
    if (groups) {
      groups.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/reports/users`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get list of record extents
   * A rendering of the geometry as a png. If no background is specified the image will be transparent. In getMap the envelope of the geometry is calculated then it is expanded by a factor.  That factor is the size of the map.  This allows the map to be slightly bigger than the geometry allowing some context to be shown. This parameter allows different factors to be chosen per scale level. Proportion is the proportion of the world that the geometry covers (bounds of WGS84)/(bounds of geometry in WGS84)  Named backgrounds allow the background parameter to be a simple key and the complete URL will be looked up from this list of named backgrounds
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<ExtentDtoApiModel>>
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<ExtentDtoApiModel>>>
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<ExtentDtoApiModel>>>
  public getAllRecordExtentAsJson(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAllRecordExtentAsJson.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<ExtentDtoApiModel>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/extents.json`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * List all metadata attachments
   * &lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/using-filestore.html\&#39;&gt;More info&lt;/a&gt;
   * @param metadataUuid The metadata UUID
   * @param sort Sort by
   * @param approved Use approved version or not
   * @param filter
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<MetadataResourceApiModel>>
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<MetadataResourceApiModel>>>
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<MetadataResourceApiModel>>>
  public getAllResources(
    metadataUuid: string,
    sort?: 'type' | 'name',
    approved?: boolean,
    filter?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAllResources.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (sort !== undefined && sort !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>sort, 'sort')
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }
    if (filter !== undefined && filter !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>filter,
        'filter'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<MetadataResourceApiModel>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/attachments`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get catalog content as RDF. This endpoint supports the same Lucene query parameters as for the GUI search.
   * .
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAsRdf(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getAsRdf(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getAsRdf(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getAsRdf(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(`${this.configuration.basePath}/records`, {
      responseType: <any>responseType_,
      withCredentials: this.configuration.withCredentials,
      headers: headers,
      observe: observe,
      reportProgress: reportProgress,
    })
  }

  /**
   * Get record related resources
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\&#39;&gt;More info&lt;/a&gt;
   * @param metadataUuid Record UUID.
   * @param type Type of related resource. If none, all resources are returned.
   * @param start Start offset for paging. Default 1. Only applies to related metadata records (ie. not for thumbnails).
   * @param rows Number of rows returned. Default 100.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    start?: number,
    rows?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<RelatedResponseApiModel>
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    start?: number,
    rows?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<RelatedResponseApiModel>>
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    start?: number,
    rows?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<RelatedResponseApiModel>>
  public getAssociatedResources(
    metadataUuid: string,
    type?: Array<
      | 'children'
      | 'parent'
      | 'brothersAndSisters'
      | 'siblings'
      | 'associated'
      | 'services'
      | 'datasets'
      | 'fcats'
      | 'hasfeaturecats'
      | 'sources'
      | 'hassources'
      | 'related'
      | 'onlines'
      | 'thumbnails'
    >,
    start?: number,
    rows?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getAssociatedResources.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (type) {
      type.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'type'
        )
      })
    }
    if (start !== undefined && start !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>start,
        'start'
      )
    }
    if (rows !== undefined && rows !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>rows, 'rows')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<RelatedResponseApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/related`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Returns a map to decode attributes in a dataset (from the associated feature catalog)
   * Retrieve related services, datasets, onlines, thumbnails, sources, ... to this records.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/index.html\&#39;&gt;More info&lt;/a&gt;
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getFeatureCatalog(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<FeatureResponseApiModel>
  public getFeatureCatalog(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<FeatureResponseApiModel>>
  public getFeatureCatalog(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<FeatureResponseApiModel>>
  public getFeatureCatalog(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getFeatureCatalog.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<FeatureResponseApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/featureCatalog`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata record as XML or JSON
   * @param metadataUuid Record UUID.
   * @param addSchemaLocation Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param increasePopularity Increase record popularity
   * @param withInfo Add geonet:info details
   * @param attachment Download as a file
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<object>
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<object>>
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<object>>
  public getRecordAs(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordAs.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (addSchemaLocation !== undefined && addSchemaLocation !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>addSchemaLocation,
        'addSchemaLocation'
      )
    }
    if (increasePopularity !== undefined && increasePopularity !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>increasePopularity,
        'increasePopularity'
      )
    }
    if (withInfo !== undefined && withInfo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withInfo,
        'withInfo'
      )
    }
    if (attachment !== undefined && attachment !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>attachment,
        'attachment'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      headers = headers.set('Accept', String(accept))
    }

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<object>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/formatters/xml`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata record as XML or JSON
   * @param metadataUuid Record UUID.
   * @param addSchemaLocation Add XSD schema location based on standard configuration (see schema-ident.xml).
   * @param increasePopularity Increase record popularity
   * @param withInfo Add geonet:info details
   * @param attachment Download as a file
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<object>
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<object>>
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<object>>
  public getRecordAs1(
    metadataUuid: string,
    addSchemaLocation?: boolean,
    increasePopularity?: boolean,
    withInfo?: boolean,
    attachment?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordAs1.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (addSchemaLocation !== undefined && addSchemaLocation !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>addSchemaLocation,
        'addSchemaLocation'
      )
    }
    if (increasePopularity !== undefined && increasePopularity !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>increasePopularity,
        'increasePopularity'
      )
    }
    if (withInfo !== undefined && withInfo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withInfo,
        'withInfo'
      )
    }
    if (attachment !== undefined && attachment !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>attachment,
        'attachment'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      headers = headers.set('Accept', String(accept))
    }

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<object>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/formatters/json`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata record as ZIP
   * Metadata Exchange Format (MEF) is returned. MEF is a ZIP file containing the metadata as XML and some others files depending on the version requested. See http://geonetwork-opensource.org/manuals/trunk/eng/users/annexes/mef-format.html.
   * @param metadataUuid Record UUID.
   * @param format MEF file format.
   * @param withRelated With related records (parent and service).
   * @param withXLinksResolved Resolve XLinks in the records.
   * @param withXLinkAttribute Preserve XLink URLs in the records.
   * @param addSchemaLocation
   * @param approved Download the approved version
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getRecordAsZip(
    metadataUuid: string,
    format?: 'simple' | 'partial' | 'full',
    withRelated?: boolean,
    withXLinksResolved?: boolean,
    withXLinkAttribute?: boolean,
    addSchemaLocation?: boolean,
    approved?: boolean,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordAsZip.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (format !== undefined && format !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>format,
        'format'
      )
    }
    if (withRelated !== undefined && withRelated !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withRelated,
        'withRelated'
      )
    }
    if (withXLinksResolved !== undefined && withXLinksResolved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withXLinksResolved,
        'withXLinksResolved'
      )
    }
    if (withXLinkAttribute !== undefined && withXLinkAttribute !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withXLinkAttribute,
        'withXLinkAttribute'
      )
    }
    if (addSchemaLocation !== undefined && addSchemaLocation !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>addSchemaLocation,
        'addSchemaLocation'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      headers = headers.set('Accept', String(accept))
    }

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/formatters/zip`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a formatted metadata record
   * @param formatterId
   * @param metadataUuid Record UUID.
   * @param accept Formatter type to use.
   * @param width
   * @param mdpath
   * @param language Optional language ISO 3 letters code to override HTTP Accept-language header.
   * @param output
   * @param approved Download the approved version
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getRecordFormattedBy(
    formatterId: string,
    metadataUuid: string,
    accept?: string,
    width?: '_25' | '_50' | '_75' | '_100',
    mdpath?: string,
    language?: string,
    output?: 'txt' | 'html' | 'xml' | 'json' | 'jsonld' | 'pdf' | 'testpdf',
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (formatterId === null || formatterId === undefined) {
      throw new Error(
        'Required parameter formatterId was null or undefined when calling getRecordFormattedBy.'
      )
    }
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordFormattedBy.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (width !== undefined && width !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>width,
        'width'
      )
    }
    if (mdpath !== undefined && mdpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>mdpath,
        'mdpath'
      )
    }
    if (language !== undefined && language !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>language,
        'language'
      )
    }
    if (output !== undefined && output !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>output,
        'output'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      headers = headers.set('Accept', String(accept))
    }

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/formatters/${encodeURIComponent(String(formatterId))}`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record sharing settings
   * Return current sharing options for a record.
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordSharingSettings(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SharingResponseApiModel>
  public getRecordSharingSettings(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SharingResponseApiModel>>
  public getRecordSharingSettings(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SharingResponseApiModel>>
  public getRecordSharingSettings(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordSharingSettings.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<SharingResponseApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/sharing`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record status history
   * @param metadataUuid Record UUID.
   * @param details
   * @param sortOrder Sort direction
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<MetadataStatusResponseApiModel>>
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<MetadataStatusResponseApiModel>>>
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<MetadataStatusResponseApiModel>>>
  public getRecordStatusHistory(
    metadataUuid: string,
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordStatusHistory.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (details !== undefined && details !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>details,
        'details'
      )
    }
    if (sortOrder !== undefined && sortOrder !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>sortOrder,
        'sortOrder'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<MetadataStatusResponseApiModel>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/status`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record status history by type
   * @param metadataUuid Record UUID.
   * @param type Type
   * @param details
   * @param sortOrder Sort direction
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<MetadataStatusResponseApiModel>>
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<MetadataStatusResponseApiModel>>>
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<MetadataStatusResponseApiModel>>>
  public getRecordStatusHistoryByType(
    metadataUuid: string,
    type: 'workflow' | 'task' | 'event',
    details?: boolean,
    sortOrder?: 'ASC' | 'DESC',
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordStatusHistoryByType.'
      )
    }
    if (type === null || type === undefined) {
      throw new Error(
        'Required parameter type was null or undefined when calling getRecordStatusHistoryByType.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (details !== undefined && details !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>details,
        'details'
      )
    }
    if (sortOrder !== undefined && sortOrder !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>sortOrder,
        'sortOrder'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<MetadataStatusResponseApiModel>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/status/${encodeURIComponent(String(type))}`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record tags
   * Tags are used to classify information.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/tag-information/tagging-with-categories.html\&#39;&gt;More info&lt;/a&gt;
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getRecordTags(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Set<MetadataCategoryApiModel>>
  public getRecordTags(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Set<MetadataCategoryApiModel>>>
  public getRecordTags(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Set<MetadataCategoryApiModel>>>
  public getRecordTags(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getRecordTags.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Set<MetadataCategoryApiModel>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/tags`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get list of metadata file downloads
   * @param dateFrom From date of the metadata downloads
   * @param dateTo To date of the metadata downloads
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getReportDataDownloads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportDataDownloads.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportDataDownloads.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (dateFrom !== undefined && dateFrom !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateFrom,
        'dateFrom'
      )
    }
    if (dateTo !== undefined && dateTo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateTo,
        'dateTo'
      )
    }
    if (groups) {
      groups.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/reports/datadownloads`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get uploaded files to metadata records during a period.
   * @param dateFrom From date of the metadata uploads
   * @param dateTo To date of the metadata uploads
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getReportDataUploads(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportDataUploads.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportDataUploads.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (dateFrom !== undefined && dateFrom !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateFrom,
        'dateFrom'
      )
    }
    if (dateTo !== undefined && dateTo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateTo,
        'dateTo'
      )
    }
    if (groups) {
      groups.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/reports/datauploads`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get the metadata not published during a period.
   * @param dateFrom From date of metadata change date
   * @param dateTo To date of metadata change date
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getReportInternalMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportInternalMetadata.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportInternalMetadata.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (dateFrom !== undefined && dateFrom !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateFrom,
        'dateFrom'
      )
    }
    if (dateTo !== undefined && dateTo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateTo,
        'dateTo'
      )
    }
    if (groups) {
      groups.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/reports/metadatainternal`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get the updated metadata during a period.
   * @param dateFrom From date of metadata change date
   * @param dateTo To date of metadata change date
   * @param groups Metadata group(s)
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getReportUpdatedMetadata(
    dateFrom: string,
    dateTo: string,
    groups?: Array<number>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (dateFrom === null || dateFrom === undefined) {
      throw new Error(
        'Required parameter dateFrom was null or undefined when calling getReportUpdatedMetadata.'
      )
    }
    if (dateTo === null || dateTo === undefined) {
      throw new Error(
        'Required parameter dateTo was null or undefined when calling getReportUpdatedMetadata.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (dateFrom !== undefined && dateFrom !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateFrom,
        'dateFrom'
      )
    }
    if (dateTo !== undefined && dateTo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateTo,
        'dateTo'
      )
    }
    if (groups) {
      groups.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'groups'
        )
      })
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/reports/metadataupdated`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a metadata resource
   * @param metadataUuid The metadata UUID
   * @param resourceId The resource identifier (ie. filename)
   * @param approved Use approved version or not
   * @param size Size (only applies to images). From 1px to 2048px.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<Array<string>>
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<Array<string>>>
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<Array<string>>>
  public getResource(
    metadataUuid: string,
    resourceId: string,
    approved?: boolean,
    size?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getResource.'
      )
    }
    if (resourceId === null || resourceId === undefined) {
      throw new Error(
        'Required parameter resourceId was null or undefined when calling getResource.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }
    if (size !== undefined && size !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>size, 'size')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<string>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/attachments/${encodeURIComponent(String(resourceId))}`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * List saved queries for this metadata
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSavedQueries(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<SavedQueryApiModel>>
  public getSavedQueries(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<SavedQueryApiModel>>>
  public getSavedQueries(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<SavedQueryApiModel>>>
  public getSavedQueries(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getSavedQueries.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<SavedQueryApiModel>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/query`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get record sharing settings
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSharingSettings(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SharingResponseApiModel>
  public getSharingSettings(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SharingResponseApiModel>>
  public getSharingSettings(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SharingResponseApiModel>>
  public getSharingSettings(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<SharingResponseApiModel>(
      `${this.configuration.basePath}/records/sharing`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get last workflow status for a record
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getStatus(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<MetadataWorkflowStatusResponseApiModel>
  public getStatus(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<MetadataWorkflowStatusResponseApiModel>>
  public getStatus(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<MetadataWorkflowStatusResponseApiModel>>
  public getStatus(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getStatus.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<MetadataWorkflowStatusResponseApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/status/workflow/last`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get suggestions
   * Analyze the record an suggest processes to improve the quality of the record.&lt;br/&gt;&lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/workflow/batchupdate-xsl.html\&#39;&gt;More info&lt;/a&gt;
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSuggestions(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<SuggestionTypeApiModel>>
  public getSuggestions(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<SuggestionTypeApiModel>>>
  public getSuggestions(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<SuggestionTypeApiModel>>>
  public getSuggestions(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getSuggestions.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<SuggestionTypeApiModel>>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/processes`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get test suites available.
   * TG13, TG2, ...
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getTestSuites(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<{ [key: string]: Array<string> }>
  public getTestSuites(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<{ [key: string]: Array<string> }>>
  public getTestSuites(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<{ [key: string]: Array<string> }>>
  public getTestSuites(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling getTestSuites.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<{ [key: string]: Array<string> }>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/validate/inspire/testsuites`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Search status
   * @param type One or more types to retrieve (ie. worflow, event, task). Default is all.
   * @param details All event details including XML changes. Responses are bigger. Default is false
   * @param author One or more event author. Default is all.
   * @param owner One or more event owners. Default is all.
   * @param id One or more record identifier. Default is all.
   * @param record One or more metadata record identifier. Default is all.
   * @param uuid One or more metadata uuid. Default is all.
   * @param dateFrom Start date
   * @param dateTo End date
   * @param from From page
   * @param size Number of records to return
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    record?: Array<number>,
    uuid?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<MetadataStatusResponseApiModel>>
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    record?: Array<number>,
    uuid?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<MetadataStatusResponseApiModel>>>
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    record?: Array<number>,
    uuid?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<MetadataStatusResponseApiModel>>>
  public getWorkflowStatusByType(
    type?: Array<'workflow' | 'task' | 'event'>,
    details?: boolean,
    author?: Array<number>,
    owner?: Array<number>,
    id?: Array<number>,
    record?: Array<number>,
    uuid?: Array<string>,
    dateFrom?: string,
    dateTo?: string,
    from?: number,
    size?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (type) {
      type.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'type'
        )
      })
    }
    if (details !== undefined && details !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>details,
        'details'
      )
    }
    if (author) {
      author.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'author'
        )
      })
    }
    if (owner) {
      owner.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'owner'
        )
      })
    }
    if (id) {
      id.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'id'
        )
      })
    }
    if (record) {
      record.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'record'
        )
      })
    }
    if (uuid) {
      uuid.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuid'
        )
      })
    }
    if (dateFrom !== undefined && dateFrom !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateFrom,
        'dateFrom'
      )
    }
    if (dateTo !== undefined && dateTo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>dateTo,
        'dateTo'
      )
    }
    if (from !== undefined && from !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>from, 'from')
    }
    if (size !== undefined && size !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>size, 'size')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<MetadataStatusResponseApiModel>>(
      `${this.configuration.basePath}/records/status/search`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Index a set of records
   * Index a set of records provided either by a bucket or a list of uuids
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public index(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<{ [key: string]: object }>
  public index(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<{ [key: string]: object }>>
  public index(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<{ [key: string]: object }>>
  public index(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<{ [key: string]: object }>(
      `${this.configuration.basePath}/records/index`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add a record
   * Add one or more record from an XML fragment, URL or file in a folder on the catalog server. When loadingfrom the catalog server folder, it might be faster to use a local filesystem harvester.
   * @param metadataType The type of record.
   * @param url URL of a file to download and insert.
   * @param serverFolder Server folder where to look for files.
   * @param recursiveSearch (Server folder import only) Recursive search in folder.
   * @param publishToAll (XML file only) Publish record.
   * @param assignToCatalog (MEF file only) Assign to current catalog.
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param category Tags to assign to the record.
   * @param rejectIfInvalid Validate the record first and reject it if not valid.
   * @param transformWith XSL transformation to apply to the record.
   * @param schema Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param extra (experimental) Add extra information to the record.
   * @param body XML fragment.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    body?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    body?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    body?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public insert(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    url?: Array<string>,
    serverFolder?: string,
    recursiveSearch?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    body?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (metadataType !== undefined && metadataType !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>metadataType,
        'metadataType'
      )
    }
    if (url) {
      url.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'url'
        )
      })
    }
    if (serverFolder !== undefined && serverFolder !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>serverFolder,
        'serverFolder'
      )
    }
    if (recursiveSearch !== undefined && recursiveSearch !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>recursiveSearch,
        'recursiveSearch'
      )
    }
    if (publishToAll !== undefined && publishToAll !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>publishToAll,
        'publishToAll'
      )
    }
    if (assignToCatalog !== undefined && assignToCatalog !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>assignToCatalog,
        'assignToCatalog'
      )
    }
    if (uuidProcessing !== undefined && uuidProcessing !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>uuidProcessing,
        'uuidProcessing'
      )
    }
    if (group !== undefined && group !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>group,
        'group'
      )
    }
    if (category) {
      category.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'category'
        )
      })
    }
    if (rejectIfInvalid !== undefined && rejectIfInvalid !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>rejectIfInvalid,
        'rejectIfInvalid'
      )
    }
    if (transformWith !== undefined && transformWith !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>transformWith,
        'transformWith'
      )
    }
    if (schema !== undefined && schema !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>schema,
        'schema'
      )
    }
    if (extra !== undefined && extra !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>extra,
        'extra'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = [
      'application/xml',
      'application/json',
      'application/x-www-form-urlencoded',
    ]
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records`,
      body,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add a record from XML or MEF/ZIP file
   * Add record in the catalog by uploading files.
   * @param metadataType The type of record.
   * @param file XML or MEF file to upload
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param category Tags to assign to the record.
   * @param rejectIfInvalid Validate the record first and reject it if not valid.
   * @param publishToAll (XML file only) Publish record.
   * @param assignToCatalog (MEF file only) Assign to current catalog.
   * @param transformWith XSL transformation to apply to the record.
   * @param schema Force the schema of the record. If not set, schema autodetection is used (and is the preferred method).
   * @param extra (experimental) Add extra information to the record.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public insertFile(
    metadataType?:
      | 'METADATA'
      | 'TEMPLATE'
      | 'SUB_TEMPLATE'
      | 'TEMPLATE_OF_SUB_TEMPLATE',
    file?: Array<Blob>,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    category?: Array<string>,
    rejectIfInvalid?: boolean,
    publishToAll?: boolean,
    assignToCatalog?: boolean,
    transformWith?: string,
    schema?: string,
    extra?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (metadataType !== undefined && metadataType !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>metadataType,
        'metadataType'
      )
    }
    if (file) {
      file.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'file'
        )
      })
    }
    if (uuidProcessing !== undefined && uuidProcessing !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>uuidProcessing,
        'uuidProcessing'
      )
    }
    if (group !== undefined && group !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>group,
        'group'
      )
    }
    if (category) {
      category.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'category'
        )
      })
    }
    if (rejectIfInvalid !== undefined && rejectIfInvalid !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>rejectIfInvalid,
        'rejectIfInvalid'
      )
    }
    if (publishToAll !== undefined && publishToAll !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>publishToAll,
        'publishToAll'
      )
    }
    if (assignToCatalog !== undefined && assignToCatalog !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>assignToCatalog,
        'assignToCatalog'
      )
    }
    if (transformWith !== undefined && transformWith !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>transformWith,
        'transformWith'
      )
    }
    if (schema !== undefined && schema !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>schema,
        'schema'
      )
    }
    if (extra !== undefined && extra !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>extra,
        'extra'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add a map metadata record from OGC OWS context
   * Add record in the catalog by uploading a map context.
   * @param title A map title
   * @param recordAbstract A map abstract
   * @param xml OGC OWS context as string
   * @param filename OGC OWS context file name
   * @param url OGC OWS context URL
   * @param viewerUrl A map viewer URL to visualize the map
   * @param overview Map overview as PNG (base64 encoded)
   * @param overviewFilename Map overview filename
   * @param topic Topic category
   * @param publishToAll Publish record.
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public insertOgcMapContextFile(
    title: string,
    recordAbstract?: string,
    xml?: string,
    filename?: string,
    url?: string,
    viewerUrl?: string,
    overview?: string,
    overviewFilename?: string,
    topic?: string,
    publishToAll?: boolean,
    uuidProcessing?: 'GENERATEUUID' | 'NOTHING' | 'OVERWRITE',
    group?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (title === null || title === undefined) {
      throw new Error(
        'Required parameter title was null or undefined when calling insertOgcMapContextFile.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (title !== undefined && title !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>title,
        'title'
      )
    }
    if (recordAbstract !== undefined && recordAbstract !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>recordAbstract,
        'recordAbstract'
      )
    }
    if (xml !== undefined && xml !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>xml, 'xml')
    }
    if (filename !== undefined && filename !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>filename,
        'filename'
      )
    }
    if (url !== undefined && url !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>url, 'url')
    }
    if (viewerUrl !== undefined && viewerUrl !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>viewerUrl,
        'viewerUrl'
      )
    }
    if (overview !== undefined && overview !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>overview,
        'overview'
      )
    }
    if (overviewFilename !== undefined && overviewFilename !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>overviewFilename,
        'overviewFilename'
      )
    }
    if (topic !== undefined && topic !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>topic,
        'topic'
      )
    }
    if (publishToAll !== undefined && publishToAll !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>publishToAll,
        'publishToAll'
      )
    }
    if (uuidProcessing !== undefined && uuidProcessing !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>uuidProcessing,
        'uuidProcessing'
      )
    }
    if (group !== undefined && group !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>group,
        'group'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/importfrommap`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Update the metadata resource visibility
   * @param metadataUuid The metadata UUID
   * @param resourceId The resource identifier (ie. filename)
   * @param visibility The visibility
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<MetadataResourceApiModel>
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public patchResource(
    metadataUuid: string,
    resourceId: string,
    visibility: 'public' | 'private',
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling patchResource.'
      )
    }
    if (resourceId === null || resourceId === undefined) {
      throw new Error(
        'Required parameter resourceId was null or undefined when calling patchResource.'
      )
    }
    if (visibility === null || visibility === undefined) {
      throw new Error(
        'Required parameter visibility was null or undefined when calling patchResource.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (visibility !== undefined && visibility !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>visibility,
        'visibility'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.patch<MetadataResourceApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/attachments/${encodeURIComponent(String(resourceId))}`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Apply a process
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @param metadataUuid Record UUID.
   * @param process Process identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public processRecord(
    metadataUuid: string,
    process: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<string>
  public processRecord(
    metadataUuid: string,
    process: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<string>>
  public processRecord(
    metadataUuid: string,
    process: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<string>>
  public processRecord(
    metadataUuid: string,
    process: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling processRecord.'
      )
    }
    if (process === null || process === undefined) {
      throw new Error(
        'Required parameter process was null or undefined when calling processRecord.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<string>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/processes/${encodeURIComponent(String(process))}`,
      null,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview process result
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @param metadataUuid Record UUID.
   * @param process Process identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<ElementApiModel>
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<ElementApiModel>>
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<ElementApiModel>>
  public processRecordPreview(
    metadataUuid: string,
    process: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling processRecordPreview.'
      )
    }
    if (process === null || process === undefined) {
      throw new Error(
        'Required parameter process was null or undefined when calling processRecordPreview.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<ElementApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/processes/${encodeURIComponent(String(process))}`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Publish one or more records
   * See record sharing for more details.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<MetadataProcessingReportApiModel>
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public publish(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/publish`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Create a new resource for a given metadata
   * @param metadataUuid The metadata UUID
   * @param visibility The sharing policy
   * @param approved Use approved version or not
   * @param inlineObject1ApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putResource(
    metadataUuid: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<MetadataResourceApiModel>
  public putResource(
    metadataUuid: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public putResource(
    metadataUuid: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public putResource(
    metadataUuid: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling putResource.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (visibility !== undefined && visibility !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>visibility,
        'visibility'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<MetadataResourceApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/attachments`,
      inlineObject1ApiModel,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Create a new resource from a URL for a given metadata
   * @param metadataUuid The metadata UUID
   * @param url The URL to load in the store
   * @param visibility The sharing policy
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<MetadataResourceApiModel>
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public putResourceFromURL(
    metadataUuid: string,
    url: string,
    visibility?: 'public' | 'private',
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling putResourceFromURL.'
      )
    }
    if (url === null || url === undefined) {
      throw new Error(
        'Required parameter url was null or undefined when calling putResourceFromURL.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (visibility !== undefined && visibility !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>visibility,
        'visibility'
      )
    }
    if (url !== undefined && url !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>url, 'url')
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataResourceApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/attachments`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Rate a record
   * User rating of metadata. If the metadata was harvested using the \&#39;GeoNetwork\&#39; protocol and the system setting localrating/enable is false (the default), the user\&#39;s rating is shared between GN nodes in this harvesting network. If the metadata was not harvested or if localrating/enable is true then \&#39;local rating\&#39; is applied, counting only rating from users of this node.&lt;br/&gt;When a remote rating is applied, the local rating is not updated. It will be updated on the next harvest run (FIXME ?).
   * @param metadataUuid Record UUID.
   * @param body Rating
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<number>
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<number>>
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<number>>
  public rateRecord(
    metadataUuid: string,
    body: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling rateRecord.'
      )
    }
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling rateRecord.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<number>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/rate`,
      body,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Restore saved content from a status record
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public restoreAtStatusSave(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling restoreAtStatusSave.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling restoreAtStatusSave.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling restoreAtStatusSave.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling restoreAtStatusSave.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/status/${encodeURIComponent(String(statusId))}.${encodeURIComponent(
        String(userId)
      )}.${encodeURIComponent(String(changeDate))}/restore`,
      null,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Save edits
   * Save the HTML form content.
   * @param metadataUuid Record UUID.
   * @param tab Tab
   * @param withAttributes
   * @param withValidationErrors
   * @param minor
   * @param status Submit for review directly after save.
   * @param commit Save current edits.
   * @param terminate Save and terminate session.
   * @param data Record as XML. TODO: rename xml
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public saveEdits(
    metadataUuid: string,
    tab?: string,
    withAttributes?: boolean,
    withValidationErrors?: boolean,
    minor?: boolean,
    status?: string,
    commit?: boolean,
    terminate?: boolean,
    data?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling saveEdits.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (tab !== undefined && tab !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>tab, 'tab')
    }
    if (withAttributes !== undefined && withAttributes !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withAttributes,
        'withAttributes'
      )
    }
    if (withValidationErrors !== undefined && withValidationErrors !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>withValidationErrors,
        'withValidationErrors'
      )
    }
    if (minor !== undefined && minor !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>minor,
        'minor'
      )
    }
    if (status !== undefined && status !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>status,
        'status'
      )
    }
    if (commit !== undefined && commit !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>commit,
        'commit'
      )
    }
    if (terminate !== undefined && terminate !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>terminate,
        'terminate'
      )
    }
    if (data !== undefined && data !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>data, 'data')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/editor`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Create an overview using the map print module
   * &lt;a href&#x3D;\&#39;http://geonetwork-opensource.org/manuals/trunk/eng/users/user-guide/associating-resources/linking-thumbnail.html#generating-a-thumbnail-using-wms-layers\&#39;&gt;More info&lt;/a&gt;
   * @param metadataUuid Record UUID.
   * @param jsonConfig The mapprint module JSON configuration
   * @param rotationAngle The rotation angle of the map
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<MetadataResourceApiModel>
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<MetadataResourceApiModel>>
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<MetadataResourceApiModel>>
  public saveThumbnail(
    metadataUuid: string,
    jsonConfig: string,
    rotationAngle?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling saveThumbnail.'
      )
    }
    if (jsonConfig === null || jsonConfig === undefined) {
      throw new Error(
        'Required parameter jsonConfig was null or undefined when calling saveThumbnail.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (jsonConfig !== undefined && jsonConfig !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>jsonConfig,
        'jsonConfig'
      )
    }
    if (rotationAngle !== undefined && rotationAngle !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>rotationAngle,
        'rotationAngle'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataResourceApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/attachments/print-thumbnail`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set group and owner for one or more records
   * @param groupIdentifier Group identifier
   * @param userIdentifier User identifier
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<MetadataProcessingReportApiModel>
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public setGroupAndOwner(
    groupIdentifier: number,
    userIdentifier: number,
    uuids?: Array<string>,
    bucket?: string,
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (groupIdentifier === null || groupIdentifier === undefined) {
      throw new Error(
        'Required parameter groupIdentifier was null or undefined when calling setGroupAndOwner.'
      )
    }
    if (userIdentifier === null || userIdentifier === undefined) {
      throw new Error(
        'Required parameter userIdentifier was null or undefined when calling setGroupAndOwner.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (groupIdentifier !== undefined && groupIdentifier !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>groupIdentifier,
        'groupIdentifier'
      )
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (userIdentifier !== undefined && userIdentifier !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>userIdentifier,
        'userIdentifier'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/ownership`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set record group
   * A record is related to one group.
   * @param metadataUuid Record UUID.
   * @param body Group identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public setRecordGroup(
    metadataUuid: string,
    body: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling setRecordGroup.'
      )
    }
    if (body === null || body === undefined) {
      throw new Error(
        'Required parameter body was null or undefined when calling setRecordGroup.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/group`,
      body,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set record group and owner
   * @param metadataUuid Record UUID.
   * @param groupIdentifier Group identifier
   * @param userIdentifier User identifier
   * @param approved Use approved version or not
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<MetadataProcessingReportApiModel>
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public setRecordOwnership(
    metadataUuid: string,
    groupIdentifier: number,
    userIdentifier: number,
    approved?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling setRecordOwnership.'
      )
    }
    if (groupIdentifier === null || groupIdentifier === undefined) {
      throw new Error(
        'Required parameter groupIdentifier was null or undefined when calling setRecordOwnership.'
      )
    }
    if (userIdentifier === null || userIdentifier === undefined) {
      throw new Error(
        'Required parameter userIdentifier was null or undefined when calling setRecordOwnership.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (groupIdentifier !== undefined && groupIdentifier !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>groupIdentifier,
        'groupIdentifier'
      )
    }
    if (userIdentifier !== undefined && userIdentifier !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>userIdentifier,
        'userIdentifier'
      )
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/ownership`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Set sharing settings for one or more records
   * See record sharing for more details.
   * @param sharingParameterApiModel Privileges
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<MetadataProcessingReportApiModel>
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public share(
    sharingParameterApiModel: SharingParameterApiModel,
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    if (
      sharingParameterApiModel === null ||
      sharingParameterApiModel === undefined
    ) {
      throw new Error(
        'Required parameter sharingParameterApiModel was null or undefined when calling share.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/sharing`,
      sharingParameterApiModel,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get saved content from the status record after changes
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<string>
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<string>>
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<string>>
  public showStatusAfter(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling showStatusAfter.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling showStatusAfter.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling showStatusAfter.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling showStatusAfter.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<string>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/status/${encodeURIComponent(String(statusId))}.${encodeURIComponent(
        String(userId)
      )}.${encodeURIComponent(String(changeDate))}/after`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get saved content from the status record before changes
   * @param metadataUuid Record UUID.
   * @param statusId Status identifier
   * @param userId User identifier
   * @param changeDate Change date
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<string>
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<string>>
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<string>>
  public showStatusBefore(
    metadataUuid: string,
    statusId: number,
    userId: number,
    changeDate: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling showStatusBefore.'
      )
    }
    if (statusId === null || statusId === undefined) {
      throw new Error(
        'Required parameter statusId was null or undefined when calling showStatusBefore.'
      )
    }
    if (userId === null || userId === undefined) {
      throw new Error(
        'Required parameter userId was null or undefined when calling showStatusBefore.'
      )
    }
    if (changeDate === null || changeDate === undefined) {
      throw new Error(
        'Required parameter changeDate was null or undefined when calling showStatusBefore.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<string>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/status/${encodeURIComponent(String(statusId))}.${encodeURIComponent(
        String(userId)
      )}.${encodeURIComponent(String(changeDate))}/before`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add tags to a record
   * @param metadataUuid Record UUID.
   * @param id Tag identifier
   * @param clear Clear all before adding new ones
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public tagRecord(
    metadataUuid: string,
    id: Array<number>,
    clear?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling tagRecord.'
      )
    }
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling tagRecord.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (id) {
      id.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'id'
        )
      })
    }
    if (clear !== undefined && clear !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>clear,
        'clear'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<any>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/tags`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Add or remove tags to one or more records
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param id Tag identifier
   * @param removeId Tag identifier to remove.
   * @param clear Clear all before adding new ones
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<MetadataProcessingReportApiModel>
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public tagRecords(
    uuids?: Array<string>,
    bucket?: string,
    id?: Array<number>,
    removeId?: Array<number>,
    clear?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (id) {
      id.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'id'
        )
      })
    }
    if (removeId) {
      removeId.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'removeId'
        )
      })
    }
    if (clear !== undefined && clear !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>clear,
        'clear'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/tags`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Trigger MEF backup archive
   * The backup contains all metadata not harvested including templates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public trigger(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<string>
  public trigger(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<string>>
  public trigger(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<string>>
  public trigger(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<string>(
      `${this.configuration.basePath}/records/backups`,
      null,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Un-publish one or more records
   * See record sharing for more details.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<MetadataProcessingReportApiModel>
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpResponse<MetadataProcessingReportApiModel>>
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<HttpEvent<MetadataProcessingReportApiModel>>
  public unpublish(
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | '*/*' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', '*/*']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<MetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/unpublish`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Remove a DOI (this is not recommended, DOI are supposed to be persistent once created. This is mainly here for testing).
   * @param metadataUuid Record UUID.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public unregisterDoi(
    metadataUuid: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<string>
  public unregisterDoi(
    metadataUuid: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<string>>
  public unregisterDoi(
    metadataUuid: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<string>>
  public unregisterDoi(
    metadataUuid: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling unregisterDoi.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<string>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/doi`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Validate a record
   * User MUST be able to edit the record to validate it. FIXME : id MUST be the id of the current metadata record in session ?
   * @param metadataUuid Record UUID.
   * @param isvalid Validation status. Should be provided only in case of SUBTEMPLATE validation. If provided for another type, throw a BadParameter Exception
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<ReportsApiModel>
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<ReportsApiModel>>
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<ReportsApiModel>>
  public validateRecord(
    metadataUuid: string,
    isvalid?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling validateRecord.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (isvalid !== undefined && isvalid !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>isvalid,
        'isvalid'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<ReportsApiModel>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/validate/internal`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Submit a record to the INSPIRE service for validation.
   * User MUST be able to edit the record to validate it. An INSPIRE endpoint must be configured in Settings. This activates an asyncronous process, this method does not return any report. This method returns an id to be used to get the report.
   * @param metadataUuid Record UUID.
   * @param testsuite Test suite to run
   * @param mode Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/plain' }
  ): Observable<string>
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/plain' }
  ): Observable<HttpResponse<string>>
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/plain' }
  ): Observable<HttpEvent<string>>
  public validateRecordForInspire(
    metadataUuid: string,
    testsuite: string,
    mode?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'text/plain' }
  ): Observable<any> {
    if (metadataUuid === null || metadataUuid === undefined) {
      throw new Error(
        'Required parameter metadataUuid was null or undefined when calling validateRecordForInspire.'
      )
    }
    if (testsuite === null || testsuite === undefined) {
      throw new Error(
        'Required parameter testsuite was null or undefined when calling validateRecordForInspire.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (testsuite !== undefined && testsuite !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>testsuite,
        'testsuite'
      )
    }
    if (mode !== undefined && mode !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>mode, 'mode')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', 'text/plain']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<string>(
      `${this.configuration.basePath}/records/${encodeURIComponent(
        String(metadataUuid)
      )}/validate/inspire`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Validate one or more records
   * Update validation status for all records.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param approved Use approved version or not
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public validateRecords(
    uuids?: Array<string>,
    approved?: boolean,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (approved !== undefined && approved !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>approved,
        'approved'
      )
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/records/validate`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Validate one or more records in INSPIRE validator
   * Update validation status for all records.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param mode Define the encoding of the record to use. By default, ISO19139 are used as is and ISO19115-3 are converted to ISO19139.If mode &#x3D; csw, a GetRecordById request is used.If mode &#x3D; any portal id, then a GetRecordById request is used on this portal CSW entry point which may define custom CSW post processing. See https://github.com/geonetwork/core-geonetwork/pull/4493.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<string>
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<string>>
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<string>>
  public validateRecordsInspire(
    uuids?: Array<string>,
    bucket?: string,
    mode?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (mode !== undefined && mode !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>mode, 'mode')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<string>(
      `${this.configuration.basePath}/records/validate/inspire`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }
}
