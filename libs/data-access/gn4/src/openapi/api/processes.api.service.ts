/**
 * GeoNetwork 4.2.7 OpenAPI Documentation
 *
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

// @ts-ignore
import { MetadataReplacementProcessingReportApiModel } from '../model/metadataReplacementProcessingReport.api.model'
// @ts-ignore
import { ProcessingReportApiModel } from '../model/processingReport.api.model'
// @ts-ignore
import { XsltMetadataProcessingReportApiModel } from '../model/xsltMetadataProcessingReport.api.model'

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'
import { BaseService } from '../api.base.service'

@Injectable({
  providedIn: 'root',
})
export class ProcessesApiService extends BaseService {
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration
  ) {
    super(basePath, configuration)
  }

  /**
   * Clear process reports list
   * @endpoint delete /processes/reports
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public _delete(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public _delete(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public _delete(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public _delete(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/processes/reports`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get current process reports
   * When processing, the report is stored in memory and allows to retrieve progress repport during processing. Usually, process reports are returned by the synchronous processing operation.
   * @endpoint get /processes/reports
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getProcessReport(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<ProcessingReportApiModel>>
  public getProcessReport(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<ProcessingReportApiModel>>>
  public getProcessReport(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<ProcessingReportApiModel>>>
  public getProcessReport(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/processes/reports`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<ProcessingReportApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview process result applied to one or more records
   * Preview result of a process applied to metadata records with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process. Append mode has 2 limitations. First, it only support a set of records in the same schema. Secondly, it does not propagate URL parameters. This mode is mainly used to create custom reports based on metadata records content.If process name ends with \&#39;.csv\&#39;, the XSL process output a text document which is returned. When errors occur during processing, the processing report is returned in JSON format.
   * @endpoint get /processes/{process}
   * @param process Process identifier
   * @param diffType Return differences with diff, diffhtml or patch
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param appendFirst Append documents before processing
   * @param applyUpdateFixedInfo Apply update fixed info
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewProcessRecords(
    process: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    appendFirst?: boolean,
    applyUpdateFixedInfo?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public previewProcessRecords(
    process: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    appendFirst?: boolean,
    applyUpdateFixedInfo?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public previewProcessRecords(
    process: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    appendFirst?: boolean,
    applyUpdateFixedInfo?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public previewProcessRecords(
    process: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    appendFirst?: boolean,
    applyUpdateFixedInfo?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (process === null || process === undefined) {
      throw new Error(
        'Required parameter process was null or undefined when calling previewProcessRecords.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>diffType,
      'diffType'
    )
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>appendFirst,
      'appendFirst'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>applyUpdateFixedInfo,
      'applyUpdateFixedInfo'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/processes/${this.configuration.encodeParam({ name: 'process', value: process, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview of search and replace text.
   *  When errors occur during processing, the processing report is returned in JSON format.
   * @endpoint get /processes/db/search-and-replace
   * @param search Value to search for
   * @param useRegexp Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   * @param replace Replacement
   * @param regexpFlags regexpFlags
   * @param diffType Return differences with diff, diffhtml or patch
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewProcessSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public previewProcessSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public previewProcessSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public previewProcessSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    diffType?: 'patch' | 'diff' | 'diffhtml',
    uuids?: Array<string>,
    bucket?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | '*/*'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (search === null || search === undefined) {
      throw new Error(
        'Required parameter search was null or undefined when calling previewProcessSearchAndReplace.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>useRegexp,
      'useRegexp'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>search,
      'search'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>replace,
      'replace'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>regexpFlags,
      'regexpFlags'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>diffType,
      'diffType'
    )
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', '*/*'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/processes/db/search-and-replace`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Apply a process to one or more records
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @endpoint post /processes/{process}
   * @param process Process identifier
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param index Index after processing
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public processRecords(
    process: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<XsltMetadataProcessingReportApiModel>
  public processRecords(
    process: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<XsltMetadataProcessingReportApiModel>>
  public processRecords(
    process: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<XsltMetadataProcessingReportApiModel>>
  public processRecords(
    process: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (process === null || process === undefined) {
      throw new Error(
        'Required parameter process was null or undefined when calling processRecords.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>updateDateStamp,
      'updateDateStamp'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>index,
      'index'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/processes/${this.configuration.encodeParam({ name: 'process', value: process, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<XsltMetadataProcessingReportApiModel>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Apply a database search and replace to one or more records
   * Process a metadata with an XSL transformation declared in the metadata schema (See the process folder). Parameters sent to the service are forwarded to XSL process.
   * @endpoint post /processes/db/search-and-replace
   * @param search Value to search for
   * @param useRegexp Use regular expression (may not be supported by all databases - tested with H2 and PostgreSQL)
   * @param replace Replacement
   * @param regexpFlags regexpFlags
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param updateDateStamp If true updates the DateStamp (or equivalent in standards different to ISO 19139) field in the metadata with the current timestamp
   * @param index Index after processing
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public processSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<XsltMetadataProcessingReportApiModel>
  public processSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<XsltMetadataProcessingReportApiModel>>
  public processSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<XsltMetadataProcessingReportApiModel>>
  public processSearchAndReplace(
    search: string,
    useRegexp?: boolean,
    replace?: string,
    regexpFlags?: string,
    uuids?: Array<string>,
    bucket?: string,
    updateDateStamp?: boolean,
    index?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (search === null || search === undefined) {
      throw new Error(
        'Required parameter search was null or undefined when calling processSearchAndReplace.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>useRegexp,
      'useRegexp'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>search,
      'search'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>replace,
      'replace'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>regexpFlags,
      'regexpFlags'
    )
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>updateDateStamp,
      'updateDateStamp'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>index,
      'index'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/processes/db/search-and-replace`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<XsltMetadataProcessingReportApiModel>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Search and replace values in one or more ISO19139 records
   * Service to apply replacements to one or more records.  To define a replacement, send the following parameters:  * mdsection-139815551372&#x3D;metadata  * mdfield-1398155513728&#x3D;id.contact.individualName  * replaceValue-1398155513728&#x3D;Juan  * searchValue-1398155513728&#x3D;Jose  &lt;br/&gt;Batch editing can also be used for similar works.
   * @endpoint post /processes/search-and-replace
   * @param process
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param isTesting Test only (ie. metadata are not saved). Return the report only.
   * @param isCaseInsensitive Case insensitive search.
   * @param vacuumMode \&#39;record\&#39; to apply vacuum.xsl, \&#39;element\&#39; to remove empty elements. Empty to not affect empty elements.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @deprecated
   */
  public searchAndReplace(
    process?: string,
    uuids?: Array<string>,
    bucket?: string,
    isTesting?: boolean,
    isCaseInsensitive?: boolean,
    vacuumMode?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<MetadataReplacementProcessingReportApiModel>
  public searchAndReplace(
    process?: string,
    uuids?: Array<string>,
    bucket?: string,
    isTesting?: boolean,
    isCaseInsensitive?: boolean,
    vacuumMode?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<MetadataReplacementProcessingReportApiModel>>
  public searchAndReplace(
    process?: string,
    uuids?: Array<string>,
    bucket?: string,
    isTesting?: boolean,
    isCaseInsensitive?: boolean,
    vacuumMode?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<MetadataReplacementProcessingReportApiModel>>
  public searchAndReplace(
    process?: string,
    uuids?: Array<string>,
    bucket?: string,
    isTesting?: boolean,
    isCaseInsensitive?: boolean,
    vacuumMode?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>process,
      'process'
    )
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>isTesting,
      'isTesting'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>isCaseInsensitive,
      'isCaseInsensitive'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>vacuumMode,
      'vacuumMode'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/processes/search-and-replace`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<MetadataReplacementProcessingReportApiModel>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }
}
