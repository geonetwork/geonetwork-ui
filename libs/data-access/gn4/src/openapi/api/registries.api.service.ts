/**
 * GeoNetwork 4.2.7 OpenAPI Documentation
 *
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

// @ts-ignore
import { CrsApiModel } from '../model/crs.api.model'
// @ts-ignore
import { SimpleMetadataProcessingReportApiModel } from '../model/simpleMetadataProcessingReport.api.model'
// @ts-ignore
import { ThesaurusInfoApiModel } from '../model/thesaurusInfo.api.model'
// @ts-ignore
import { UploadThesaurusRequestApiModel } from '../model/uploadThesaurusRequest.api.model'

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'
import { BaseService } from '../api.base.service'

@Injectable({
  providedIn: 'root',
})
export class RegistriesApiService extends BaseService {
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration
  ) {
    super(basePath, configuration)
  }

  /**
   * Delete a thesaurus by name
   * Delete a thesaurus.
   * @endpoint delete /registries/vocabularies/{thesaurus}
   * @param thesaurus Thesaurus to delete.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public deleteThesaurus(
    thesaurus: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling deleteThesaurus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies/${this.configuration.encodeParam({ name: 'thesaurus', value: thesaurus, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>(
      'delete',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Extracts directory entries from records
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).&lt;br/&gt;&lt;br/&gt;Only records that the current user can edit are analyzed.&lt;br/&gt;&lt;br/&gt;Examples:&lt;br/&gt;For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * @endpoint put /registries/actions/entries/collect
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling extractEntries.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>xpath,
      'xpath'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/actions/entries/collect`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get CRS
   * @endpoint get /registries/crs/{id}
   * @param id CRS identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCrs(
    id: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<CrsApiModel>
  public getCrs(
    id: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<CrsApiModel>>
  public getCrs(
    id: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<CrsApiModel>>
  public getCrs(
    id: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getCrs.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/crs/${this.configuration.encodeParam({ name: 'id', value: id, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<CrsApiModel>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get list of CRS type
   * @endpoint get /registries/crs/types
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCrsTypes(
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<string>>
  public getCrsTypes(
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<string>>>
  public getCrsTypes(
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<string>>>
  public getCrsTypes(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/crs/types`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<string>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a directory entry
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
   * @endpoint get /registries/entries/{uuid}
   * @param uuid Directory entry UUID.
   * @param process Process
   * @param transformation Transformation
   * @param lang lang
   * @param schema schema
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (uuid === null || uuid === undefined) {
      throw new Error(
        'Required parameter uuid was null or undefined when calling getEntry.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (process) {
      process.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'process'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformation,
      'transformation'
    )
    if (lang) {
      lang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'lang'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>schema,
      'schema'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/entries/${this.configuration.encodeParam({ name: 'uuid', value: uuid, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Get keyword by id
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \&#39;to-iso19139-keyword\&#39; is the default and return an ISO19139 snippet.\&#39;to-iso19139-keyword-as-xlink\&#39; return an XLinked element. Custom transformation can be create on a per schema basis.
   * @endpoint post /registries/vocabularies/keyword
   * @param id Keyword identifier or list of keyword identifiers comma separated.
   * @param thesaurus Thesaurus to look info for the keyword(s).
   * @param lang Languages.
   * @param keywordOnly Only print the keyword, no thesaurus information.
   * @param transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param langMap langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getKeywordById.'
      )
    }
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getKeywordById.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>id,
      'id'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurus,
      'thesaurus'
    )
    if (lang) {
      lang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'lang'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>keywordOnly,
      'keywordOnly'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformation,
      'transformation'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>langMap,
      'langMap'
    )

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies/keyword`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get keyword by id
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \&#39;to-iso19139-keyword\&#39; is the default and return an ISO19139 snippet.\&#39;to-iso19139-keyword-as-xlink\&#39; return an XLinked element. Custom transformation can be create on a per schema basis.
   * @endpoint get /registries/vocabularies/keyword
   * @param id Keyword identifier or list of keyword identifiers comma separated.
   * @param thesaurus Thesaurus to look info for the keyword(s).
   * @param lang Languages.
   * @param keywordOnly Only print the keyword, no thesaurus information.
   * @param transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param langMap langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getKeywordById1.'
      )
    }
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getKeywordById1.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>id,
      'id'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurus,
      'thesaurus'
    )
    if (lang) {
      lang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'lang'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>keywordOnly,
      'keywordOnly'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>transformation,
      'transformation'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>langMap,
      'langMap'
    )

    let localVarHeaders = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      localVarHeaders = localVarHeaders.set('Accept', String(accept))
    }

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies/keyword`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Download a thesaurus by name
   * Download the thesaurus in SKOS format.
   * @endpoint get /registries/vocabularies/{thesaurus}
   * @param thesaurus Thesaurus to download.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getThesaurus(
    thesaurus: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public getThesaurus(
    thesaurus: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public getThesaurus(
    thesaurus: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public getThesaurus(
    thesaurus: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getThesaurus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies/${this.configuration.encodeParam({ name: 'thesaurus', value: thesaurus, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('get', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Uploads a CSV file and convert it to SKOS format
   * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
   * @endpoint post /registries/vocabularies/import/csv
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param encoding Encoding. Default is UTF-8.
   * @param thesaurusNs Thesaurus namespace. Default is filename.
   * @param languages Thesaurus languages
   * @param thesaurusTitle Thesaurus title. Default is filename.
   * @param conceptIdColumn Column name for concept id. Default is id.
   * @param conceptLabelColumn Column name for concept label. Default is label.
   * @param conceptDescriptionColumn Column name for concept description. Default is description.
   * @param conceptBroaderIdColumn Column name for broader concept id. Default is broader.
   * @param conceptNarrowerIdColumn Column name for narrower concept id. Default is narrower.
   * @param conceptRelatedIdColumn Column name for related concept id. Default is related.
   * @param conceptLinkSeparator Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
   * @param importAsThesaurus Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
   * @param uploadThesaurusRequestApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>type,
      'type'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dir,
      'dir'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>encoding,
      'encoding'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurusNs,
      'thesaurusNs'
    )
    if (languages) {
      languages.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'languages'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>thesaurusTitle,
      'thesaurusTitle'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptIdColumn,
      'conceptIdColumn'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptLabelColumn,
      'conceptLabelColumn'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptDescriptionColumn,
      'conceptDescriptionColumn'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptBroaderIdColumn,
      'conceptBroaderIdColumn'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptNarrowerIdColumn,
      'conceptNarrowerIdColumn'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptRelatedIdColumn,
      'conceptRelatedIdColumn'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>conceptLinkSeparator,
      'conceptLinkSeparator'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>importAsThesaurus,
      'importAsThesaurus'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies/import/csv`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: uploadThesaurusRequestApiModel,
      params: localVarQueryParameters,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Import spatial directory entries
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
   * @endpoint post /registries/actions/entries/import/spatial
   * @param file The ZIP file to upload containing the Shapefile.
   * @param uuidAttribute Attribute to use for UUID. If none, random UUID are generated.
   * @param uuidPattern Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
   * @param descriptionAttribute Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
   * @param geomProjectionTo geomProjectionTo
   * @param lenient lenient
   * @param charset Attribute table charset
   * @param onlyBoundingBox Create only bounding box for each spatial objects.
   * @param process Process
   * @param schema Schema identifier
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (file === null || file === undefined) {
      throw new Error(
        'Required parameter file was null or undefined when calling importSpatialEntries.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidAttribute,
      'uuidAttribute'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidPattern,
      'uuidPattern'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>descriptionAttribute,
      'descriptionAttribute'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>geomProjectionTo,
      'geomProjectionTo'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>lenient,
      'lenient'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>charset,
      'charset'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>onlyBoundingBox,
      'onlyBoundingBox'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>process,
      'process'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>schema,
      'schema'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uuidProcessing,
      'uuidProcessing'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>group,
      'group'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['multipart/form-data']

    const canConsumeForm = this.canConsumeForm(consumes)

    let localVarFormParams: { append(param: string, value: any): any }
    let localVarUseForm = false
    let localVarConvertFormParamsToString = false
    // use FormData to transmit files using content-type "multipart/form-data"
    // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
    localVarUseForm = canConsumeForm
    if (localVarUseForm) {
      localVarFormParams = new FormData()
    } else {
      localVarFormParams = new HttpParams({ encoder: this.encoder })
    }

    if (file !== undefined) {
      localVarFormParams =
        (localVarFormParams.append('file', <any>file) as any) ||
        localVarFormParams
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/actions/entries/import/spatial`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<SimpleMetadataProcessingReportApiModel>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: localVarConvertFormParamsToString
          ? localVarFormParams.toString()
          : localVarFormParams,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview directory entries extracted from records
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).&lt;br/&gt;&lt;br/&gt;Only records that the current user can edit are analyzed.&lt;br/&gt;&lt;br/&gt;Examples:&lt;br/&gt;For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * @endpoint get /registries/actions/entries/collect
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling previewExtractedEntries.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>xpath,
      'xpath'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/actions/entries/collect`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview updated matching entries in records
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).&lt;br/&gt;&lt;br/&gt;The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @endpoint get /registries/actions/entries/synchronize
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role/_*_/@codeListValue
   * @param substituteAsXLink Replace entry by XLink.
   * @param fq Filter query for directory search.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling previewUpdatedRecordEntries.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>xpath,
      'xpath'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath'
    )
    if (propertiesToCopy) {
      propertiesToCopy.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'propertiesToCopy'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>substituteAsXLink,
      'substituteAsXLink'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>fq,
      'fq'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/actions/entries/synchronize`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Search coordinate reference system (CRS)
   * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
   * @endpoint get /registries/crs
   * @param q Search value
   * @param type Type of CRS
   * @param rows Number of results. Default is: 100
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<Array<CrsApiModel>>
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<Array<CrsApiModel>>>
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<Array<CrsApiModel>>>
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>q,
      'q'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>type,
      'type'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>rows,
      'rows'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/crs`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<Array<CrsApiModel>>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Search keywords
   * @endpoint get /registries/vocabularies/search
   * @param q Query
   * @param lang Query in that language
   * @param rows Number of rows
   * @param start Start from
   * @param pLang Return keyword information in one or more languages
   * @param thesaurus Thesaurus identifier
   * @param type Type of search
   * @param uri URI query
   * @param sort Sort by
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'application/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>q,
      'q'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>lang,
      'lang'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>rows,
      'rows'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>start,
      'start'
    )
    if (pLang) {
      pLang.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'pLang'
        )
      })
    }
    if (thesaurus) {
      thesaurus.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'thesaurus'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>type,
      'type'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>uri,
      'uri'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>sort,
      'sort'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept([
        'application/json',
        'application/xml',
      ])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies/search`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'get',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Update matching entries in records
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).&lt;br/&gt;&lt;br/&gt;The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @endpoint put /registries/actions/entries/synchronize
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role/_*_/@codeListValue
   * @param substituteAsXLink Replace entry by XLink.
   * @param fq Filter query for directory search.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<object>
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<object>>
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<object>>
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling updateRecordEntries.'
      )
    }

    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>bucket,
      'bucket'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>xpath,
      'xpath'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>identifierXpath,
      'identifierXpath'
    )
    if (propertiesToCopy) {
      propertiesToCopy.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'propertiesToCopy'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>substituteAsXLink,
      'substituteAsXLink'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>fq,
      'fq'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/actions/entries/synchronize`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<object>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Updates the information of a local thesaurus
   * Updates the information of a local thesaurus.
   * @endpoint put /registries/vocabularies/{thesaurus}
   * @param thesaurus Thesaurus to update.
   * @param thesaurusInfoApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any>
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<any>>
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<any>>
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling updateThesaurus.'
      )
    }
    if (thesaurusInfoApiModel === null || thesaurusInfoApiModel === undefined) {
      throw new Error(
        'Required parameter thesaurusInfoApiModel was null or undefined when calling updateThesaurus.'
      )
    }

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies/${this.configuration.encodeParam({ name: 'thesaurus', value: thesaurus, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<any>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: thesaurusInfoApiModel,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      ...(localVarTransferCache !== undefined
        ? { transferCache: localVarTransferCache }
        : {}),
      reportProgress: reportProgress,
    })
  }

  /**
   * Uploads a new thesaurus from a file
   * Uploads a new thesaurus.
   * @endpoint post /registries/vocabularies
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
   * @param uploadThesaurusRequestApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    uploadThesaurusRequestApiModel?: UploadThesaurusRequestApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>type,
      'type'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dir,
      'dir'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>stylesheet,
      'stylesheet'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'text/xml'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: uploadThesaurusRequestApiModel,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Uploads a new thesaurus from URL or Registry
   * Uploads a new thesaurus.
   * @endpoint put /registries/vocabularies
   * @param url If set, try to download from the Internet.
   * @param registryUrl If set, try to download from a registry.
   * @param registryType If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
   * @param registryLanguage Languages to download from a registry.
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
   * @param thesaurusInfoApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<string>
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpResponse<string>>
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<HttpEvent<string>>
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json' | 'text/xml'
      context?: HttpContext
      transferCache?: boolean
    }
  ): Observable<any> {
    let localVarQueryParameters = new HttpParams({ encoder: this.encoder })
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>url,
      'url'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>registryUrl,
      'registryUrl'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>registryType,
      'registryType'
    )
    if (registryLanguage) {
      registryLanguage.forEach((element) => {
        localVarQueryParameters = this.addToHttpParams(
          localVarQueryParameters,
          <any>element,
          'registryLanguage'
        )
      })
    }
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>type,
      'type'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>dir,
      'dir'
    )
    localVarQueryParameters = this.addToHttpParams(
      localVarQueryParameters,
      <any>stylesheet,
      'stylesheet'
    )

    let localVarHeaders = this.defaultHeaders

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ??
      this.configuration.selectHeaderAccept(['application/json', 'text/xml'])
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Accept',
        localVarHttpHeaderAcceptSelected
      )
    }

    const localVarHttpContext: HttpContext =
      options?.context ?? new HttpContext()

    const localVarTransferCache: boolean = options?.transferCache ?? true

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set(
        'Content-Type',
        httpContentTypeSelected
      )
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json'
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text'
      } else if (
        this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)
      ) {
        responseType_ = 'json'
      } else {
        responseType_ = 'blob'
      }
    }

    let localVarPath = `/registries/vocabularies`
    const { basePath, withCredentials } = this.configuration
    return this.httpClient.request<string>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: thesaurusInfoApiModel,
        params: localVarQueryParameters,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        ...(localVarTransferCache !== undefined
          ? { transferCache: localVarTransferCache }
          : {}),
        reportProgress: reportProgress,
      }
    )
  }
}
