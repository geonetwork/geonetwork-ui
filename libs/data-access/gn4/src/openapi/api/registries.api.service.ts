/**
 * GeoNetwork 4.2.7 OpenAPI Documentation
 * This is the description of the GeoNetwork OpenAPI. Use this API to manage your catalog.
 *
 * The version of the OpenAPI document: 4.2.7
 * Contact: geonetwork-users@lists.sourceforge.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
} from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

import { CrsApiModel } from '../model/models'
import { InlineObject1ApiModel } from '../model/models'
import { InlineObject4ApiModel } from '../model/models'
import { SimpleMetadataProcessingReportApiModel } from '../model/models'
import { ThesaurusInfoApiModel } from '../model/models'

import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'

@Injectable({
  providedIn: 'root',
})
export class RegistriesApiService {
  protected basePath = 'https://demo.georchestra.org/geonetwork/srv/api'
  public defaultHeaders = new HttpHeaders()
  public configuration = new Configuration()
  public encoder: HttpParameterCodec

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath
      }
      this.configuration.basePath = basePath
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data'
    for (const consume of consumes) {
      if (form === consume) {
        return true
      }
    }
    return false
  }

  private addToHttpParams(
    httpParams: HttpParams,
    value: any,
    key?: string
  ): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value)
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key)
    }
    return httpParams
  }

  private addToHttpParamsRecursive(
    httpParams: HttpParams,
    value?: any,
    key?: string
  ): HttpParams {
    if (value == null) {
      return httpParams
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        ;(value as any[]).forEach(
          (elem) =>
            (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key))
        )
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(
            key,
            (value as Date).toISOString().substr(0, 10)
          )
        } else {
          throw Error('key may not be null if value is Date')
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k
            ))
        )
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value)
    } else {
      throw Error('key may not be null if value is not object or array')
    }
    return httpParams
  }

  /**
   * Delete a thesaurus by name
   * Delete a thesaurus.
   * @param thesaurus Thesaurus to delete.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public deleteThesaurus(
    thesaurus: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public deleteThesaurus(
    thesaurus: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling deleteThesaurus.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.delete<any>(
      `${
        this.configuration.basePath
      }/registries/vocabularies/${encodeURIComponent(String(thesaurus))}`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Extracts directory entries from records
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).&lt;br/&gt;&lt;br/&gt;Only records that the current user can edit are analyzed.&lt;br/&gt;&lt;br/&gt;Examples:&lt;br/&gt;For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<object>
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<object>>
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<object>>
  public extractEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling extractEntries.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (xpath !== undefined && xpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>xpath,
        'xpath'
      )
    }
    if (identifierXpath !== undefined && identifierXpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>identifierXpath,
        'identifierXpath'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<object>(
      `${this.configuration.basePath}/registries/actions/entries/collect`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get CRS
   * @param id CRS identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCrs(
    id: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<CrsApiModel>
  public getCrs(
    id: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<CrsApiModel>>
  public getCrs(
    id: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<CrsApiModel>>
  public getCrs(
    id: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getCrs.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<CrsApiModel>(
      `${this.configuration.basePath}/registries/crs/${encodeURIComponent(
        String(id)
      )}`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get list of CRS type
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getCrsTypes(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<string>>
  public getCrsTypes(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<string>>>
  public getCrsTypes(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<string>>>
  public getCrsTypes(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<string>>(
      `${this.configuration.basePath}/registries/crs/types`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get a directory entry
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records using XLinks. XLinks can be remote or local.
   * @param uuid Directory entry UUID.
   * @param process Process
   * @param transformation Transformation
   * @param lang lang
   * @param schema schema
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getEntry(
    uuid: string,
    process?: Array<string>,
    transformation?: string,
    lang?: Array<string>,
    schema?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (uuid === null || uuid === undefined) {
      throw new Error(
        'Required parameter uuid was null or undefined when calling getEntry.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (process) {
      process.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'process'
        )
      })
    }
    if (transformation !== undefined && transformation !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>transformation,
        'transformation'
      )
    }
    if (lang) {
      lang.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'lang'
        )
      })
    }
    if (schema !== undefined && schema !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>schema,
        'schema'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${this.configuration.basePath}/registries/entries/${encodeURIComponent(
        String(uuid)
      )}`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get keyword by id
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \&#39;to-iso19139-keyword\&#39; is the default and return an ISO19139 snippet.\&#39;to-iso19139-keyword-as-xlink\&#39; return an XLinked element. Custom transformation can be create on a per schema basis.
   * @param id Keyword identifier or list of keyword identifiers comma separated.
   * @param thesaurus Thesaurus to look info for the keyword(s).
   * @param lang Languages.
   * @param keywordOnly Only print the keyword, no thesaurus information.
   * @param transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param langMap langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<object>
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<object>>
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<object>>
  public getKeywordById(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getKeywordById.'
      )
    }
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getKeywordById.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (id !== undefined && id !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>id, 'id')
    }
    if (thesaurus !== undefined && thesaurus !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>thesaurus,
        'thesaurus'
      )
    }
    if (lang) {
      lang.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'lang'
        )
      })
    }
    if (keywordOnly !== undefined && keywordOnly !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>keywordOnly,
        'keywordOnly'
      )
    }
    if (transformation !== undefined && transformation !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>transformation,
        'transformation'
      )
    }
    if (langMap !== undefined && langMap !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>langMap,
        'langMap'
      )
    }

    let headers = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      headers = headers.set('Accept', String(accept))
    }

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<object>(
      `${this.configuration.basePath}/registries/vocabularies/keyword`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get keyword by id
   * Retrieve XML representation of keyword(s) from same thesaurususing different transformations. \&#39;to-iso19139-keyword\&#39; is the default and return an ISO19139 snippet.\&#39;to-iso19139-keyword-as-xlink\&#39; return an XLinked element. Custom transformation can be create on a per schema basis.
   * @param id Keyword identifier or list of keyword identifiers comma separated.
   * @param thesaurus Thesaurus to look info for the keyword(s).
   * @param lang Languages.
   * @param keywordOnly Only print the keyword, no thesaurus information.
   * @param transformation XSL template to use (ISO19139 keyword by default, see convert.xsl).
   * @param langMap langMap, that converts the values in the \&#39;lang\&#39; parameter to how they will be actually represented in the record. {\&#39;fre\&#39;:\&#39;fra\&#39;} or {\&#39;fre\&#39;:\&#39;fr\&#39;}.  Missing/empty means to convert to iso 2 letter.
   * @param accept
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<object>
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<object>>
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<object>>
  public getKeywordById1(
    id: string,
    thesaurus: string,
    lang?: Array<string>,
    keywordOnly?: boolean,
    transformation?: string,
    langMap?: string,
    accept?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        'Required parameter id was null or undefined when calling getKeywordById1.'
      )
    }
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getKeywordById1.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (id !== undefined && id !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>id, 'id')
    }
    if (thesaurus !== undefined && thesaurus !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>thesaurus,
        'thesaurus'
      )
    }
    if (lang) {
      lang.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'lang'
        )
      })
    }
    if (keywordOnly !== undefined && keywordOnly !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>keywordOnly,
        'keywordOnly'
      )
    }
    if (transformation !== undefined && transformation !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>transformation,
        'transformation'
      )
    }
    if (langMap !== undefined && langMap !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>langMap,
        'langMap'
      )
    }

    let headers = this.defaultHeaders
    if (accept !== undefined && accept !== null) {
      headers = headers.set('Accept', String(accept))
    }

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<object>(
      `${this.configuration.basePath}/registries/vocabularies/keyword`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Download a thesaurus by name
   * Download the thesaurus in SKOS format.
   * @param thesaurus Thesaurus to download.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getThesaurus(
    thesaurus: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public getThesaurus(
    thesaurus: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public getThesaurus(
    thesaurus: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public getThesaurus(
    thesaurus: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling getThesaurus.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<any>(
      `${
        this.configuration.basePath
      }/registries/vocabularies/${encodeURIComponent(String(thesaurus))}`,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Uploads a CSV file and convert it to SKOS format
   * CSV file MUST contains columns at least for concept id and label. For multilingual thesaurus, consider using columns like label, label_fre, label_ita with languages parameter set to [en, fr, it]. Default language value is used if translations are empty. The thesaurus filename will be the filename of the CSV file (with .rdf extension). It is recommended to set the thesaurus title and namespace URL even if default values will be used based on the filename. Thesaurus dates are set to the date of import.
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param encoding Encoding. Default is UTF-8.
   * @param thesaurusNs Thesaurus namespace. Default is filename.
   * @param languages Thesaurus languages
   * @param thesaurusTitle Thesaurus title. Default is filename.
   * @param conceptIdColumn Column name for concept id. Default is id.
   * @param conceptLabelColumn Column name for concept label. Default is label.
   * @param conceptDescriptionColumn Column name for concept description. Default is description.
   * @param conceptBroaderIdColumn Column name for broader concept id. Default is broader.
   * @param conceptNarrowerIdColumn Column name for narrower concept id. Default is narrower.
   * @param conceptRelatedIdColumn Column name for related concept id. Default is related.
   * @param conceptLinkSeparator Separator used when multiple broader/narrower/related ids are in the same column. Default is \&#39;|\&#39;.
   * @param importAsThesaurus Import CSV file as thesaurus if true (detault) or return it in  SKOS format.
   * @param inlineObject4ApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    inlineObject4ApiModel?: InlineObject4ApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    inlineObject4ApiModel?: InlineObject4ApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    inlineObject4ApiModel?: InlineObject4ApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public importCsvAsThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    encoding?: string,
    thesaurusNs?: string,
    languages?: Array<string>,
    thesaurusTitle?: string,
    conceptIdColumn?: string,
    conceptLabelColumn?: string,
    conceptDescriptionColumn?: string,
    conceptBroaderIdColumn?: string,
    conceptNarrowerIdColumn?: string,
    conceptRelatedIdColumn?: string,
    conceptLinkSeparator?: string,
    importAsThesaurus?: boolean,
    inlineObject4ApiModel?: InlineObject4ApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (type !== undefined && type !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>type, 'type')
    }
    if (dir !== undefined && dir !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>dir, 'dir')
    }
    if (encoding !== undefined && encoding !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>encoding,
        'encoding'
      )
    }
    if (thesaurusNs !== undefined && thesaurusNs !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>thesaurusNs,
        'thesaurusNs'
      )
    }
    if (languages) {
      languages.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'languages'
        )
      })
    }
    if (thesaurusTitle !== undefined && thesaurusTitle !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>thesaurusTitle,
        'thesaurusTitle'
      )
    }
    if (conceptIdColumn !== undefined && conceptIdColumn !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>conceptIdColumn,
        'conceptIdColumn'
      )
    }
    if (conceptLabelColumn !== undefined && conceptLabelColumn !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>conceptLabelColumn,
        'conceptLabelColumn'
      )
    }
    if (
      conceptDescriptionColumn !== undefined &&
      conceptDescriptionColumn !== null
    ) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>conceptDescriptionColumn,
        'conceptDescriptionColumn'
      )
    }
    if (
      conceptBroaderIdColumn !== undefined &&
      conceptBroaderIdColumn !== null
    ) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>conceptBroaderIdColumn,
        'conceptBroaderIdColumn'
      )
    }
    if (
      conceptNarrowerIdColumn !== undefined &&
      conceptNarrowerIdColumn !== null
    ) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>conceptNarrowerIdColumn,
        'conceptNarrowerIdColumn'
      )
    }
    if (
      conceptRelatedIdColumn !== undefined &&
      conceptRelatedIdColumn !== null
    ) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>conceptRelatedIdColumn,
        'conceptRelatedIdColumn'
      )
    }
    if (conceptLinkSeparator !== undefined && conceptLinkSeparator !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>conceptLinkSeparator,
        'conceptLinkSeparator'
      )
    }
    if (importAsThesaurus !== undefined && importAsThesaurus !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>importAsThesaurus,
        'importAsThesaurus'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<any>(
      `${this.configuration.basePath}/registries/vocabularies/import/csv`,
      inlineObject4ApiModel,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Import spatial directory entries
   * Directory entry (AKA subtemplates) are XML fragments that can be inserted in metadata records. Use this service to import geographic extent entries from an ESRI Shapefile format.
   * @param file The ZIP file to upload containing the Shapefile.
   * @param uuidAttribute Attribute to use for UUID. If none, random UUID are generated.
   * @param uuidPattern Pattern to build UUID from. Default is \&#39;{{uuid}}\&#39;.
   * @param descriptionAttribute Attribute to use for extent description. If none, no extent description defined. TODO: Add per language desc ?
   * @param geomProjectionTo geomProjectionTo
   * @param lenient lenient
   * @param charset Attribute table charset
   * @param onlyBoundingBox Create only bounding box for each spatial objects.
   * @param process Process
   * @param schema Schema identifier
   * @param uuidProcessing Record identifier processing.
   * @param group The group the record is attached to.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<SimpleMetadataProcessingReportApiModel>
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<SimpleMetadataProcessingReportApiModel>>
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<SimpleMetadataProcessingReportApiModel>>
  public importSpatialEntries(
    file: Blob,
    uuidAttribute?: string,
    uuidPattern?: string,
    descriptionAttribute?: string,
    geomProjectionTo?: string,
    lenient?: boolean,
    charset?: string,
    onlyBoundingBox?: boolean,
    process?: string,
    schema?: string,
    uuidProcessing?:
      | 'GENERATEUUID'
      | 'NOTHING'
      | 'OVERWRITE'
      | 'REMOVE_AND_REPLACE',
    group?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (file === null || file === undefined) {
      throw new Error(
        'Required parameter file was null or undefined when calling importSpatialEntries.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuidAttribute !== undefined && uuidAttribute !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>uuidAttribute,
        'uuidAttribute'
      )
    }
    if (uuidPattern !== undefined && uuidPattern !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>uuidPattern,
        'uuidPattern'
      )
    }
    if (descriptionAttribute !== undefined && descriptionAttribute !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>descriptionAttribute,
        'descriptionAttribute'
      )
    }
    if (geomProjectionTo !== undefined && geomProjectionTo !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>geomProjectionTo,
        'geomProjectionTo'
      )
    }
    if (lenient !== undefined && lenient !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>lenient,
        'lenient'
      )
    }
    if (charset !== undefined && charset !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>charset,
        'charset'
      )
    }
    if (onlyBoundingBox !== undefined && onlyBoundingBox !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>onlyBoundingBox,
        'onlyBoundingBox'
      )
    }
    if (process !== undefined && process !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>process,
        'process'
      )
    }
    if (schema !== undefined && schema !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>schema,
        'schema'
      )
    }
    if (uuidProcessing !== undefined && uuidProcessing !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>uuidProcessing,
        'uuidProcessing'
      )
    }
    if (group !== undefined && group !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>group,
        'group'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['multipart/form-data']

    const canConsumeForm = this.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    let convertFormParamsToString = false
    // use FormData to transmit files using content-type "multipart/form-data"
    // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
    useForm = canConsumeForm
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new HttpParams({ encoder: this.encoder })
    }

    if (file !== undefined) {
      formParams = (formParams.append('file', <any>file) as any) || formParams
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<SimpleMetadataProcessingReportApiModel>(
      `${this.configuration.basePath}/registries/actions/entries/import/spatial`,
      convertFormParamsToString ? formParams.toString() : formParams,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview directory entries extracted from records
   * Scan one or more records for element matching the XPath provided and save them as directory entries (ie. subtemplate).&lt;br/&gt;&lt;br/&gt;Only records that the current user can edit are analyzed.&lt;br/&gt;&lt;br/&gt;Examples:&lt;br/&gt;For ISO19115-3 records, use .//cit:CI_Responsibility and compute identifier based on email with .//cit:electronicMailAddress/_*_/text() to create a contact directory.
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<object>
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<object>>
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<object>>
  public previewExtractedEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling previewExtractedEntries.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (xpath !== undefined && xpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>xpath,
        'xpath'
      )
    }
    if (identifierXpath !== undefined && identifierXpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>identifierXpath,
        'identifierXpath'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<object>(
      `${this.configuration.basePath}/registries/actions/entries/collect`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Preview updated matching entries in records
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).&lt;br/&gt;&lt;br/&gt;The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role/_*_/@codeListValue
   * @param substituteAsXLink Replace entry by XLink.
   * @param fq Filter query for directory search.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<object>
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<object>>
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<object>>
  public previewUpdatedRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling previewUpdatedRecordEntries.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (xpath !== undefined && xpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>xpath,
        'xpath'
      )
    }
    if (identifierXpath !== undefined && identifierXpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>identifierXpath,
        'identifierXpath'
      )
    }
    if (propertiesToCopy) {
      propertiesToCopy.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'propertiesToCopy'
        )
      })
    }
    if (substituteAsXLink !== undefined && substituteAsXLink !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>substituteAsXLink,
        'substituteAsXLink'
      )
    }
    if (fq !== undefined && fq !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>fq, 'fq')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<object>(
      `${this.configuration.basePath}/registries/actions/entries/synchronize`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Search coordinate reference system (CRS)
   * Based on GeoTools EPSG database. If phrase query, each words are searched separately.
   * @param q Search value
   * @param type Type of CRS
   * @param rows Number of results. Default is: 100
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<CrsApiModel>>
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<CrsApiModel>>>
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<CrsApiModel>>>
  public searchCrs(
    q?: string,
    type?:
      | 'CoordinateReferenceSystem'
      | 'VerticalCRS'
      | 'GeographicCRS'
      | 'ProjectedCRS',
    rows?: number,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (q !== undefined && q !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>q, 'q')
    }
    if (type !== undefined && type !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>type, 'type')
    }
    if (rows !== undefined && rows !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>rows, 'rows')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<Array<CrsApiModel>>(
      `${this.configuration.basePath}/registries/crs`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Search keywords
   * @param q Query
   * @param lang Query in that language
   * @param rows Number of rows
   * @param start Start from
   * @param pLang Return keyword information in one or more languages
   * @param thesaurus Thesaurus identifier
   * @param type Type of search
   * @param uri URI query
   * @param sort Sort by
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<object>
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpResponse<object>>
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<HttpEvent<object>>
  public searchKeywords(
    q?: string,
    lang?: string,
    rows?: number,
    start?: number,
    pLang?: Array<string>,
    thesaurus?: Array<string>,
    type?: 'STARTS_WITH' | 'CONTAINS' | 'MATCH',
    uri?: string,
    sort?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'application/xml' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (q !== undefined && q !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>q, 'q')
    }
    if (lang !== undefined && lang !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>lang, 'lang')
    }
    if (rows !== undefined && rows !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>rows, 'rows')
    }
    if (start !== undefined && start !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>start,
        'start'
      )
    }
    if (pLang) {
      pLang.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'pLang'
        )
      })
    }
    if (thesaurus) {
      thesaurus.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'thesaurus'
        )
      })
    }
    if (type !== undefined && type !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>type, 'type')
    }
    if (uri !== undefined && uri !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>uri, 'uri')
    }
    if (sort !== undefined && sort !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>sort, 'sort')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = [
        'application/json',
        'application/xml',
      ]
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.get<object>(
      `${this.configuration.basePath}/registries/vocabularies/search`,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Update matching entries in records
   * Scan one or more records for element matching the XPath provided and then check if this element is available in the directory. If Found, the element from the directory update the element in the record and optionally text or attribute value properties are preserved using propertiesToCopy. Elements can be lost if not existing in the directory entry (eg. from an gex:Extent directory containing only description and bounding polygon, the update can remove temporal element).&lt;br/&gt;&lt;br/&gt;The identifier XPath is used to find a match. An optional filtercan be added to restrict search to a subset of the directory. If no identifier XPaths is provided, the UUID is based on the content of the snippet (hash). It is recommended to use an identifier for better matching (eg. ISO19139 contact with different roles will not match on the automatic UUID mode).
   * @param xpath XPath of the elements to extract as entry.
   * @param uuids Record UUIDs. If null current selection is used.
   * @param bucket Selection bucket name
   * @param identifierXpath XPath of the element identifier. If not defined a random UUID is generated and analysis will not check for duplicates.
   * @param propertiesToCopy List of XPath of properties to copy from record to matching entry. Only support text or attribute eg. ./gmd:role/_*_/@codeListValue
   * @param substituteAsXLink Replace entry by XLink.
   * @param fq Filter query for directory search.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<object>
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<object>>
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<object>>
  public updateRecordEntries(
    xpath: string,
    uuids?: Array<string>,
    bucket?: string,
    identifierXpath?: string,
    propertiesToCopy?: Array<string>,
    substituteAsXLink?: boolean,
    fq?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (xpath === null || xpath === undefined) {
      throw new Error(
        'Required parameter xpath was null or undefined when calling updateRecordEntries.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (uuids) {
      uuids.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'uuids'
        )
      })
    }
    if (bucket !== undefined && bucket !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>bucket,
        'bucket'
      )
    }
    if (xpath !== undefined && xpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>xpath,
        'xpath'
      )
    }
    if (identifierXpath !== undefined && identifierXpath !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>identifierXpath,
        'identifierXpath'
      )
    }
    if (propertiesToCopy) {
      propertiesToCopy.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'propertiesToCopy'
        )
      })
    }
    if (substituteAsXLink !== undefined && substituteAsXLink !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>substituteAsXLink,
        'substituteAsXLink'
      )
    }
    if (fq !== undefined && fq !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>fq, 'fq')
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<object>(
      `${this.configuration.basePath}/registries/actions/entries/synchronize`,
      null,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Updates the information of a local thesaurus
   * Updates the information of a local thesaurus.
   * @param thesaurus Thesaurus to update.
   * @param thesaurusInfoApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any>
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<any>>
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<any>>
  public updateThesaurus(
    thesaurus: string,
    thesaurusInfoApiModel: ThesaurusInfoApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (thesaurus === null || thesaurus === undefined) {
      throw new Error(
        'Required parameter thesaurus was null or undefined when calling updateThesaurus.'
      )
    }
    if (thesaurusInfoApiModel === null || thesaurusInfoApiModel === undefined) {
      throw new Error(
        'Required parameter thesaurusInfoApiModel was null or undefined when calling updateThesaurus.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<any>(
      `${
        this.configuration.basePath
      }/registries/vocabularies/${encodeURIComponent(String(thesaurus))}`,
      thesaurusInfoApiModel,
      {
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Uploads a new thesaurus from a file
   * Uploads a new thesaurus.
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
   * @param inlineObject1ApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<string>
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<HttpResponse<string>>
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<HttpEvent<string>>
  public uploadThesaurus(
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    inlineObject1ApiModel?: InlineObject1ApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (type !== undefined && type !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>type, 'type')
    }
    if (dir !== undefined && dir !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>dir, 'dir')
    }
    if (stylesheet !== undefined && stylesheet !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>stylesheet,
        'stylesheet'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', 'text/xml']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.post<string>(
      `${this.configuration.basePath}/registries/vocabularies`,
      inlineObject1ApiModel,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Uploads a new thesaurus from URL or Registry
   * Uploads a new thesaurus.
   * @param url If set, try to download from the Internet.
   * @param registryUrl If set, try to download from a registry.
   * @param registryType If using registryUrl, then define the type of registry. If not set, default mode is re3gistry.
   * @param registryLanguage Languages to download from a registry.
   * @param type Local or external (default).
   * @param dir Type of thesaurus, usually one of the ISO thesaurus type codelist value. Default is theme.
   * @param stylesheet XSL to be use to convert the thesaurus before load. Default _none_.
   * @param thesaurusInfoApiModel
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<string>
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<HttpResponse<string>>
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<HttpEvent<string>>
  public uploadThesaurusFromUrl(
    url?: string,
    registryUrl?: string,
    registryType?: 're3gistry' | 'ldRegistry',
    registryLanguage?: Array<string>,
    type?: 'external' | 'local',
    dir?: string,
    stylesheet?: string,
    thesaurusInfoApiModel?: ThesaurusInfoApiModel,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' | 'text/xml' }
  ): Observable<any> {
    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (url !== undefined && url !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>url, 'url')
    }
    if (registryUrl !== undefined && registryUrl !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>registryUrl,
        'registryUrl'
      )
    }
    if (registryType !== undefined && registryType !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>registryType,
        'registryType'
      )
    }
    if (registryLanguage) {
      registryLanguage.forEach((element) => {
        queryParameters = this.addToHttpParams(
          queryParameters,
          <any>element,
          'registryLanguage'
        )
      })
    }
    if (type !== undefined && type !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>type, 'type')
    }
    if (dir !== undefined && dir !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>dir, 'dir')
    }
    if (stylesheet !== undefined && stylesheet !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>stylesheet,
        'stylesheet'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json', 'text/xml']
      httpHeaderAcceptSelected =
        this.configuration.selectHeaderAccept(httpHeaderAccepts)
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['application/json']
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes)
    if (httpContentTypeSelected !== undefined) {
      headers = headers.set('Content-Type', httpContentTypeSelected)
    }

    let responseType_: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType_ = 'text'
    }

    return this.httpClient.put<string>(
      `${this.configuration.basePath}/registries/vocabularies`,
      thesaurusInfoApiModel,
      {
        params: queryParameters,
        responseType: <any>responseType_,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }
}
