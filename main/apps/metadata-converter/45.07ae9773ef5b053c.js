(self.webpackChunkmetadata_converter=self.webpackChunkmetadata_converter||[]).push([[45],{8257:X=>{"use strict";X.exports=function Z(u){return null===u||"object"!=typeof u||null!=u.toJSON?JSON.stringify(u):Array.isArray(u)?"["+u.reduce((S,w,h)=>S+(0===h?"":",")+Z(void 0===w||"symbol"==typeof w?null:w),"")+"]":"{"+Object.keys(u).sort().reduce((S,w,h)=>void 0===u[w]||"symbol"==typeof u[w]?S:S+(0===S.length?"":",")+Z(w)+":"+Z(u[w]),"")+"}"}},8398:(X,Z,u)=>{"use strict";var S=u(4510).default;const{isArray:w,isObject:h,isString:g}=u(9098),{asArray:J}=u(6035),{prependBase:r}=u(3834),t=u(9027),n=u(7192);function y(k){throw new t("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:k})}function N({context:k,base:c}){if(!k)return;const l=k["@context"];if(g(l))k["@context"]=r(c,l);else if(w(l))for(let j=0;j<l.length;++j){const o=l[j];g(o)?l[j]=r(c,o):h(o)&&N({context:{"@context":o},base:c})}else if(h(l))for(const j in l)N({context:l[j],base:c})}X.exports=class{constructor({sharedCache:c}){this.perOpCache=new Map,this.sharedCache=c}resolve(c){var l=this;return S(function*({activeCtx:j,context:o,documentLoader:L,base:b,cycles:Y=new Set}){o&&h(o)&&o["@context"]&&(o=o["@context"]),o=J(o);const R=[];for(const e of o){if(g(e)){let m=l._get(e);m||(m=yield l._resolveRemoteContext({activeCtx:j,url:e,documentLoader:L,base:b,cycles:Y})),w(m)?R.push(...m):R.push(m);continue}if(null===e){R.push(new n({document:null}));continue}h(e)||y(o);const a=JSON.stringify(e);let s=l._get(a);s||(s=new n({document:e}),l._cacheResolvedContext({key:a,resolved:s,tag:"static"})),R.push(s)}return R}).apply(this,arguments)}_get(c){let l=this.perOpCache.get(c);if(!l){const j=this.sharedCache.get(c);j&&(l=j.get("static"),l&&this.perOpCache.set(c,l))}return l}_cacheResolvedContext({key:c,resolved:l,tag:j}){if(this.perOpCache.set(c,l),void 0!==j){let o=this.sharedCache.get(c);o||(o=new Map,this.sharedCache.set(c,o)),o.set(j,l)}return l}_resolveRemoteContext(c){var l=this;return S(function*({activeCtx:j,url:o,documentLoader:L,base:b,cycles:Y}){o=r(b,o);const{context:R,remoteDoc:e}=yield l._fetchContext({activeCtx:j,url:o,documentLoader:L,cycles:Y});N({context:R,base:b=e.documentUrl||o});const a=yield l.resolve({activeCtx:j,context:R,documentLoader:L,base:b,cycles:Y});return l._cacheResolvedContext({key:o,resolved:a,tag:e.tag}),a}).apply(this,arguments)}_fetchContext(c){return S(function*({activeCtx:l,url:j,documentLoader:o,cycles:L}){if(L.size>10)throw new t("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:"json-ld-1.0"===l.processingMode?"loading remote context failed":"context overflow",max:10});if(L.has(j))throw new t("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:"json-ld-1.0"===l.processingMode?"recursive context inclusion":"context overflow",url:j});let b,Y;L.add(j);try{Y=yield o(j),b=Y.document||null,g(b)&&(b=JSON.parse(b))}catch(R){throw new t(`Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context. URL: "${j}".`,"jsonld.InvalidUrl",{code:"loading remote context failed",url:j,cause:R})}if(!h(b))throw new t(`Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object. URL: "${j}".`,"jsonld.InvalidUrl",{code:"invalid remote context",url:j});return b="@context"in b?{"@context":b["@context"]}:{"@context":{}},Y.contextUrl&&(w(b["@context"])||(b["@context"]=[b["@context"]]),b["@context"].push(Y.contextUrl)),{context:b,remoteDoc:Y}}).apply(this,arguments)}}},9027:X=>{"use strict";X.exports=class extends Error{constructor(u="An unspecified JSON-LD error occurred.",S="jsonld.Error",w={}){super(u),this.name=S,this.message=u,this.details=w}}},1985:X=>{"use strict";X.exports=Z=>{class u{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(u,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(u.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:u}),u.compact=function(S,w){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):Z.compact(S,w)},u.expand=function(S){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):Z.expand(S)},u.flatten=function(S){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):Z.flatten(S)},u}},6441:(X,Z,u)=>{"use strict";X.exports=u(7073).NQuads},7579:(X,Z,u)=>{"use strict";var S=u(4510).default;X.exports=class{constructor(){this._requests={}}wrapLoader(h){const g=this;return g._loader=h,function(){return g.add.apply(g,arguments)}}add(h){var g=this;return S(function*(){let J=g._requests[h];if(J)return Promise.resolve(J);J=g._requests[h]=g._loader(h);try{return yield J}finally{delete g._requests[h]}})()}}},7192:(X,Z,u)=>{"use strict";const S=u(1983);X.exports=class{constructor({document:g}){this.document=g,this.cache=new S({max:10})}getProcessed(g){return this.cache.get(g)}setProcessed(g,J){this.cache.set(g,J)}}},7374:(X,Z,u)=>{"use strict";var S=u(4510).default;const w=u(9027),{isArray:h,isObject:g,isString:J,isUndefined:r}=u(9098),{isList:t,isValue:n,isGraph:i,isSimpleGraph:y,isSubjectReference:N}=u(2926),{expandIri:k,getContextValue:c,isKeyword:l,process:j,processingMode:o}=u(3104),{removeBase:L,prependBase:b}=u(3834),{REGEX_KEYWORD:Y,addValue:R,asArray:e,compareShortestLeast:a}=u(6035),s={};function T(A,f,v){if("@nest"!==k(A,f,{vocab:!0},v))throw new w("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}X.exports=s,s.compact=function(){var A=S(function*({activeCtx:f,activeProperty:v=null,element:_,options:O={}}){if(h(_)){let $=[];for(let E=0;E<_.length;++E){const p=yield s.compact({activeCtx:f,activeProperty:v,element:_[E],options:O});null!==p&&$.push(p)}return O.compactArrays&&1===$.length&&0===(c(f,v,"@container")||[]).length&&($=$[0]),$}const H=c(f,v,"@context");if(r(H)||(f=yield j({activeCtx:f,localCtx:H,propagate:!0,overrideProtected:!0,options:O})),g(_)){if(O.link&&"@id"in _&&O.link.hasOwnProperty(_["@id"])){const G=O.link[_["@id"]];for(let Q=0;Q<G.length;++Q)if(G[Q].expanded===_)return G[Q].compacted}if(n(_)||N(_)){const G=s.compactValue({activeCtx:f,activeProperty:v,value:_,options:O});return O.link&&N(_)&&(O.link.hasOwnProperty(_["@id"])||(O.link[_["@id"]]=[]),O.link[_["@id"]].push({expanded:_,compacted:G})),G}if(t(_)&&(c(f,v,"@container")||[]).includes("@list"))return s.compact({activeCtx:f,activeProperty:v,element:_["@list"],options:O});const $="@reverse"===v,E={},p=f;!n(_)&&!N(_)&&(f=f.revertToPreviousContext());const x=c(p,v,"@context");r(x)||(f=yield j({activeCtx:f,localCtx:x,propagate:!0,overrideProtected:!0,options:O})),O.link&&"@id"in _&&(O.link.hasOwnProperty(_["@id"])||(O.link[_["@id"]]=[]),O.link[_["@id"]].push({expanded:_,compacted:E}));let P=_["@type"]||[];P.length>1&&(P=Array.from(P).sort());const M=f;for(const G of P){const Q=s.compactIri({activeCtx:M,iri:G,relativeTo:{vocab:!0}}),z=c(p,Q,"@context");r(z)||(f=yield j({activeCtx:f,localCtx:z,options:O,propagate:!1}))}const d=Object.keys(_).sort();for(const G of d){const Q=_[G];if("@id"!==G)if("@type"!==G)if("@reverse"!==G)if("@preserve"!==G)if("@index"!==G)if("@graph"!==G&&"@list"!==G&&"@included"!==G&&l(G)){const z=s.compactIri({activeCtx:f,iri:G,relativeTo:{vocab:!0}});R(E,z,Q)}else{if(!h(Q))throw new w("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(0===Q.length){const z=s.compactIri({activeCtx:f,iri:G,value:Q,relativeTo:{vocab:!0},reverse:$}),K=f.mappings.has(z)?f.mappings.get(z)["@nest"]:null;let F=E;K&&(T(f,K,O),g(E[K])||(E[K]={}),F=E[K]),R(F,z,Q,{propertyIsArray:!0})}for(const z of Q){const K=s.compactIri({activeCtx:f,iri:G,value:z,relativeTo:{vocab:!0},reverse:$}),F=f.mappings.has(K)?f.mappings.get(K)["@nest"]:null;let V=E;F&&(T(f,F,O),g(E[F])||(E[F]={}),V=E[F]);const D=c(f,K,"@container")||[],I=i(z),B=t(z);let W;B?W=z["@list"]:I&&(W=z["@graph"]);let U=yield s.compact({activeCtx:f,activeProperty:K,element:B||I?W:z,options:O});if(B){if(h(U)||(U=[U]),D.includes("@list")){R(V,K,U,{valueIsArray:!0,allowDuplicate:!0});continue}U={[s.compactIri({activeCtx:f,iri:"@list",relativeTo:{vocab:!0}})]:U},"@index"in z&&(U[s.compactIri({activeCtx:f,iri:"@index",relativeTo:{vocab:!0}})]=z["@index"])}if(I)if(D.includes("@graph")&&(D.includes("@id")||D.includes("@index")&&y(z))){let C;V.hasOwnProperty(K)?C=V[K]:V[K]=C={};const ee=(D.includes("@id")?z["@id"]:z["@index"])||s.compactIri({activeCtx:f,iri:"@none",relativeTo:{vocab:!0}});R(C,ee,U,{propertyIsArray:!O.compactArrays||D.includes("@set")})}else D.includes("@graph")&&y(z)?(h(U)&&U.length>1&&(U={"@included":U}),R(V,K,U,{propertyIsArray:!O.compactArrays||D.includes("@set")})):(h(U)&&1===U.length&&O.compactArrays&&(U=U[0]),U={[s.compactIri({activeCtx:f,iri:"@graph",relativeTo:{vocab:!0}})]:U},"@id"in z&&(U[s.compactIri({activeCtx:f,iri:"@id",relativeTo:{vocab:!0}})]=z["@id"]),"@index"in z&&(U[s.compactIri({activeCtx:f,iri:"@index",relativeTo:{vocab:!0}})]=z["@index"]),R(V,K,U,{propertyIsArray:!O.compactArrays||D.includes("@set")}));else if(D.includes("@language")||D.includes("@index")||D.includes("@id")||D.includes("@type")){let C,ee;if(V.hasOwnProperty(K)?C=V[K]:V[K]=C={},D.includes("@language"))n(U)&&(U=U["@value"]),ee=z["@language"];else if(D.includes("@index")){const te=c(f,K,"@index")||"@index",q=s.compactIri({activeCtx:f,iri:te,relativeTo:{vocab:!0}});if("@index"===te)ee=z["@index"],delete U[q];else{let ne;if([ee,...ne]=e(U[te]||[]),J(ee))switch(ne.length){case 0:delete U[te];break;case 1:U[te]=ne[0];break;default:U[te]=ne}else ee=null}}else if(D.includes("@id")){const te=s.compactIri({activeCtx:f,iri:"@id",relativeTo:{vocab:!0}});ee=U[te],delete U[te]}else if(D.includes("@type")){const te=s.compactIri({activeCtx:f,iri:"@type",relativeTo:{vocab:!0}});let q;switch([ee,...q]=e(U[te]||[]),q.length){case 0:delete U[te];break;case 1:U[te]=q[0];break;default:U[te]=q}1===Object.keys(U).length&&"@id"in z&&(U=yield s.compact({activeCtx:f,activeProperty:K,element:{"@id":z["@id"]},options:O}))}ee||(ee=s.compactIri({activeCtx:f,iri:"@none",relativeTo:{vocab:!0}})),R(C,ee,U,{propertyIsArray:D.includes("@set")})}else{const C=!O.compactArrays||D.includes("@set")||D.includes("@list")||h(U)&&0===U.length||"@list"===G||"@graph"===G;R(V,K,U,{propertyIsArray:C})}}}else{if((c(f,v,"@container")||[]).includes("@index"))continue;const K=s.compactIri({activeCtx:f,iri:G,relativeTo:{vocab:!0}});R(E,K,Q)}else{const z=yield s.compact({activeCtx:f,activeProperty:v,element:Q,options:O});h(z)&&0===z.length||R(E,G,z)}else{const z=yield s.compact({activeCtx:f,activeProperty:"@reverse",element:Q,options:O});for(const K in z)if(f.mappings.has(K)&&f.mappings.get(K).reverse){const F=z[K],D=(c(f,K,"@container")||[]).includes("@set")||!O.compactArrays;R(E,K,F,{propertyIsArray:D}),delete z[K]}if(Object.keys(z).length>0){const K=s.compactIri({activeCtx:f,iri:G,relativeTo:{vocab:!0}});R(E,K,z)}}else{let z=e(Q).map(I=>s.compactIri({activeCtx:p,iri:I,relativeTo:{vocab:!0}}));1===z.length&&(z=z[0]);const K=s.compactIri({activeCtx:f,iri:"@type",relativeTo:{vocab:!0}}),D=(c(f,K,"@container")||[]).includes("@set")&&o(f,1.1)||h(z)&&0===Q.length;R(E,K,z,{propertyIsArray:D})}else{let z=e(Q).map(F=>s.compactIri({activeCtx:f,iri:F,relativeTo:{vocab:!1},base:O.base}));1===z.length&&(z=z[0]),E[s.compactIri({activeCtx:f,iri:"@id",relativeTo:{vocab:!0}})]=z}}return E}return _});return function(f){return A.apply(this,arguments)}}(),s.compactIri=({activeCtx:A,iri:f,value:v=null,relativeTo:_={vocab:!1},reverse:O=!1,base:H=null})=>{if(null===f)return f;A.isPropertyTermScoped&&A.previousContext&&(A=A.previousContext);const $=A.getInverse();if(l(f)&&f in $&&"@none"in $[f]&&"@type"in $[f]["@none"]&&"@none"in $[f]["@none"]["@type"])return $[f]["@none"]["@type"]["@none"];if(_.vocab&&f in $){const M=A["@language"]||"@none",d=[];g(v)&&"@index"in v&&!("@graph"in v)&&d.push("@index","@index@set"),g(v)&&"@preserve"in v&&(v=v["@preserve"][0]),i(v)?("@index"in v&&d.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in v&&d.push("@graph@id","@graph@id@set"),d.push("@graph","@graph@set","@set"),"@index"in v||d.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in v||d.push("@graph@id","@graph@id@set")):g(v)&&!n(v)&&d.push("@id","@id@set","@type","@set@type");let G="@language",Q="@null";if(O)G="@type",Q="@reverse",d.push("@set");else if(t(v)){"@index"in v||d.push("@list");const K=v["@list"];if(0===K.length)G="@any",Q="@none";else{let F=0===K.length?M:null,V=null;for(let D=0;D<K.length;++D){const I=K[D];let B="@none",W="@none";if(n(I)?"@direction"in I?B=`${(I["@language"]||"").toLowerCase()}_${I["@direction"]}`:"@language"in I?B=I["@language"].toLowerCase():"@type"in I?W=I["@type"]:B="@null":W="@id",null===F?F=B:B!==F&&n(I)&&(F="@none"),null===V?V=W:W!==V&&(V="@none"),"@none"===F&&"@none"===V)break}F=F||"@none",V=V||"@none","@none"!==V?(G="@type",Q=V):Q=F}}else{if(n(v))if("@language"in v&&!("@index"in v)){d.push("@language","@language@set"),Q=v["@language"];const K=v["@direction"];K&&(Q=`${Q}_${K}`)}else"@direction"in v&&!("@index"in v)?Q=`_${v["@direction"]}`:"@type"in v&&(G="@type",Q=v["@type"]);else G="@type",Q="@id";d.push("@set")}d.push("@none"),g(v)&&!("@index"in v)&&d.push("@index","@index@set"),n(v)&&1===Object.keys(v).length&&d.push("@language","@language@set");const z=function m(A,f,v,_,O,H){null===H&&(H="@null");const $=[];if(("@id"===H||"@reverse"===H)&&g(v)&&"@id"in v){"@reverse"===H&&$.push("@reverse");const p=s.compactIri({activeCtx:A,iri:v["@id"],relativeTo:{vocab:!0}});A.mappings.has(p)&&A.mappings.get(p)&&A.mappings.get(p)["@id"]===v["@id"]?$.push.apply($,["@vocab","@id"]):$.push.apply($,["@id","@vocab"])}else{$.push(H);const p=$.find(x=>x.includes("_"));p&&$.push(p.replace(/^[^_]+_/,"_"))}$.push("@none");const E=A.inverse[f];for(const p of _){if(!(p in E))continue;const x=E[p][O];for(const P of $)if(P in x)return x[P]}return null}(A,f,v,d,G,Q);if(null!==z)return z}if(_.vocab&&"@vocab"in A){const M=A["@vocab"];if(0===f.indexOf(M)&&f!==M){const d=f.substr(M.length);if(!A.mappings.has(d))return d}}let E=null;const p=[];let x=A.fastCurieMap;const P=f.length-1;for(let M=0;M<P&&f[M]in x;++M)x=x[f[M]],""in x&&p.push(x[""][0]);for(let M=p.length-1;M>=0;--M){const d=p[M],G=d.terms;for(const Q of G){const z=Q+":"+f.substr(d.iri.length);A.mappings.get(Q)._prefix&&(!A.mappings.has(z)||null===v&&A.mappings.get(z)["@id"]===f)&&(null===E||a(z,E)<0)&&(E=z)}}if(null!==E)return E;for(const[M,d]of A.mappings)if(d&&d._prefix&&f.startsWith(M+":"))throw new w(`Absolute IRI "${f}" confused with prefix "${M}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:A});if(!_.vocab){if("@base"in A){if(A["@base"]){const M=L(b(H,A["@base"]),f);return Y.test(M)?`./${M}`:M}return f}return L(H,f)}return f},s.compactValue=({activeCtx:A,activeProperty:f,value:v,options:_})=>{if(n(v)){const E=c(A,f,"@type"),p=c(A,f,"@language"),x=c(A,f,"@direction"),P=c(A,f,"@container")||[],M="@index"in v&&!P.includes("@index");if(!M&&"@none"!==E&&(v["@type"]===E||"@language"in v&&v["@language"]===p&&"@direction"in v&&v["@direction"]===x||"@language"in v&&v["@language"]===p||"@direction"in v&&v["@direction"]===x))return v["@value"];const d=Object.keys(v).length,G=1===d||2===d&&"@index"in v&&!M,Q="@language"in A,z=J(v["@value"]),K=A.mappings.has(f)&&null===A.mappings.get(f)["@language"];if(G&&"@none"!==E&&(!Q||!z||K))return v["@value"];const F={};return M&&(F[s.compactIri({activeCtx:A,iri:"@index",relativeTo:{vocab:!0}})]=v["@index"]),"@type"in v?F[s.compactIri({activeCtx:A,iri:"@type",relativeTo:{vocab:!0}})]=s.compactIri({activeCtx:A,iri:v["@type"],relativeTo:{vocab:!0}}):"@language"in v&&(F[s.compactIri({activeCtx:A,iri:"@language",relativeTo:{vocab:!0}})]=v["@language"]),"@direction"in v&&(F[s.compactIri({activeCtx:A,iri:"@direction",relativeTo:{vocab:!0}})]=v["@direction"]),F[s.compactIri({activeCtx:A,iri:"@value",relativeTo:{vocab:!0}})]=v["@value"],F}const O=k(A,f,{vocab:!0},_),H=c(A,f,"@type"),$=s.compactIri({activeCtx:A,iri:v["@id"],relativeTo:{vocab:"@vocab"===H},base:_.base});return"@id"===H||"@vocab"===H||"@graph"===O?$:{[s.compactIri({activeCtx:A,iri:"@id",relativeTo:{vocab:!0}})]:$}}},6270:X=>{"use strict";const Z="http://www.w3.org/1999/02/22-rdf-syntax-ns#",u="http://www.w3.org/2001/XMLSchema#";X.exports={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:Z,RDF_LIST:Z+"List",RDF_FIRST:Z+"first",RDF_REST:Z+"rest",RDF_NIL:Z+"nil",RDF_TYPE:Z+"type",RDF_PLAIN_LITERAL:Z+"PlainLiteral",RDF_XML_LITERAL:Z+"XMLLiteral",RDF_JSON_LITERAL:Z+"JSON",RDF_OBJECT:Z+"object",RDF_LANGSTRING:Z+"langString",XSD:u,XSD_BOOLEAN:u+"boolean",XSD_DOUBLE:u+"double",XSD_INTEGER:u+"integer",XSD_STRING:u+"string"}},3104:(X,Z,u)=>{"use strict";var S=u(4510).default;const w=u(6035),h=u(9027),{isArray:g,isObject:J,isString:r,isUndefined:t}=u(9098),{isAbsolute:n,isRelative:i,prependBase:y}=u(3834),{handleEvent:N}=u(9802),{REGEX_BCP47:k,REGEX_KEYWORD:c,asArray:l,compareShortestLeast:j}=u(6035),o=new Map,b={};function Y(e,a,s,m,T,A){if(null===a||!r(a)||b.isKeyword(a))return a;if(a.match(c))return null;if(m&&m.hasOwnProperty(a)&&!0!==T.get(a)&&b.createTermDefinition({activeCtx:e,localCtx:m,term:a,defined:T,options:A}),(s=s||{}).vocab){const v=e.mappings.get(a);if(null===v)return null;if(J(v)&&"@id"in v)return v["@id"]}const f=a.indexOf(":");if(f>0){const v=a.substr(0,f),_=a.substr(f+1);if("_"===v||0===_.indexOf("//"))return a;m&&m.hasOwnProperty(v)&&b.createTermDefinition({activeCtx:e,localCtx:m,term:v,defined:T,options:A});const O=e.mappings.get(v);if(O&&O._prefix)return O["@id"]+_;if(n(a))return a}if(s.vocab&&"@vocab"in e)a=e["@vocab"]+a;else if(s.base){let v,_;"@base"in e?e["@base"]?(_=y(A.base,e["@base"]),v=y(_,a)):(_=e["@base"],v=a):(_=A.base,v=y(A.base,a)),a=v}return a}function R(e,a){if(!e||"object"!=typeof e||!a||"object"!=typeof a)return e===a;const s=Array.isArray(e);if(s!==Array.isArray(a))return!1;if(s){if(e.length!==a.length)return!1;for(let A=0;A<e.length;++A)if(!R(e[A],a[A]))return!1;return!0}const m=Object.keys(e),T=Object.keys(a);if(m.length!==T.length)return!1;for(const A in e){let f=e[A],v=a[A];if("@container"===A&&Array.isArray(f)&&Array.isArray(v)&&(f=f.slice().sort(),v=v.slice().sort()),!R(f,v))return!1}return!0}X.exports=b,b.process=function(){var e=S(function*({activeCtx:a,localCtx:s,options:m,propagate:T=!0,overrideProtected:A=!1,cycles:f=new Set}){if(J(s)&&"@context"in s&&g(s["@context"])&&(s=s["@context"]),0===l(s).length)return a;const _=[],O=[({event:p,next:x})=>{_.push(p),x()}];m.eventHandler&&O.push(m.eventHandler);const H=m;m={...m,eventHandler:O};const $=yield m.contextResolver.resolve({activeCtx:a,context:s,documentLoader:m.documentLoader,base:m.base});J($[0].document)&&"boolean"==typeof $[0].document["@propagate"]&&(T=$[0].document["@propagate"]);let E=a;!T&&!E.previousContext&&(E=E.clone(),E.previousContext=a);for(const p of $){let{document:x}=p;if(a=E,null===x){if(!A&&0!==Object.keys(a.protected).length)throw new h("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});E=a=b.getInitialContext(m).clone();continue}const P=p.getProcessed(a);if(P){if(H.eventHandler)for(const d of P.events)N({event:d,options:H});E=a=P.context;continue}if(J(x)&&"@context"in x&&(x=x["@context"]),!J(x))throw new h("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:x});E=E.clone();const M=new Map;if("@version"in x){if(1.1!==x["@version"])throw new h("Unsupported JSON-LD version: "+x["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:x});if(a.processingMode&&"json-ld-1.0"===a.processingMode)throw new h("@version: "+x["@version"]+" not compatible with "+a.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:x});E.processingMode="json-ld-1.1",E["@version"]=x["@version"],M.set("@version",!0)}if(E.processingMode=E.processingMode||a.processingMode,"@base"in x){let d=x["@base"];if(null!==d&&!n(d)){if(!i(d))throw new h('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:x});d=y(E["@base"],d)}E["@base"]=d,M.set("@base",!0)}if("@vocab"in x){const d=x["@vocab"];if(null===d)delete E["@vocab"];else{if(!r(d))throw new h('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:x});if(!n(d)&&b.processingMode(E,1))throw new h('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:x});{const G=Y(E,d,{vocab:!0,base:!0},void 0,void 0,m);n(G)||m.eventHandler&&N({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:G}},options:m}),E["@vocab"]=G}}M.set("@vocab",!0)}if("@language"in x){const d=x["@language"];if(null===d)delete E["@language"];else{if(!r(d))throw new h('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:x});d.match(k)||m.eventHandler&&N({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:d}},options:m}),E["@language"]=d.toLowerCase()}M.set("@language",!0)}if("@direction"in x){const d=x["@direction"];if("json-ld-1.0"===a.processingMode)throw new h("Invalid JSON-LD syntax; @direction not compatible with "+a.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:x});if(null===d)delete E["@direction"];else{if("ltr"!==d&&"rtl"!==d)throw new h('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:x});E["@direction"]=d}M.set("@direction",!0)}if("@propagate"in x){const d=x["@propagate"];if("json-ld-1.0"===a.processingMode)throw new h("Invalid JSON-LD syntax; @propagate not compatible with "+a.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:x});if("boolean"!=typeof d)throw new h("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:s});M.set("@propagate",!0)}if("@import"in x){const d=x["@import"];if("json-ld-1.0"===a.processingMode)throw new h("Invalid JSON-LD syntax; @import not compatible with "+a.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:x});if(!r(d))throw new h("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:s});const G=yield m.contextResolver.resolve({activeCtx:a,context:d,documentLoader:m.documentLoader,base:m.base});if(1!==G.length)throw new h("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:s});const Q=G[0].getProcessed(a);if(Q)x=Q;else{const z=G[0].document;if("@import"in z)throw new h("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:s});for(const K in z)x.hasOwnProperty(K)||(x[K]=z[K]);G[0].setProcessed(a,x)}M.set("@import",!0)}M.set("@protected",x["@protected"]||!1);for(const d in x)if(b.createTermDefinition({activeCtx:E,localCtx:x,term:d,defined:M,options:m,overrideProtected:A}),J(x[d])&&"@context"in x[d]){const G=x[d]["@context"];let Q=!0;if(r(G)){const z=y(m.base,G);f.has(z)?Q=!1:f.add(z)}if(Q)try{yield b.process({activeCtx:E.clone(),localCtx:x[d]["@context"],overrideProtected:!0,options:m,cycles:f})}catch{throw new h("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:x[d]["@context"],term:d})}}p.setProcessed(a,{context:E,events:_})}return E});return function(a){return e.apply(this,arguments)}}(),b.createTermDefinition=({activeCtx:e,localCtx:a,term:s,defined:m,options:T,overrideProtected:A=!1})=>{if(m.has(s)){if(m.get(s))return;throw new h("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:a,term:s})}let f;if(m.set(s,!1),a.hasOwnProperty(s)&&(f=a[s]),"@type"===s&&J(f)&&"@set"===(f["@container"]||"@set")&&b.processingMode(e,1.1)){const p=["@container","@id","@protected"],x=Object.keys(f);if(0===x.length||x.some(P=>!p.includes(P)))throw new h("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:a,term:s})}else{if(b.isKeyword(s))throw new h("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:a,term:s});if(s.match(c))return void(T.eventHandler&&N({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:s}},options:T}));if(""===s)throw new h("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:a})}const v=e.mappings.get(s);e.mappings.has(s)&&e.mappings.delete(s);let _=!1;if((r(f)||null===f)&&(_=!0,f={"@id":f}),!J(f))throw new h("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:a});const O={};e.mappings.set(s,O),O.reverse=!1;const H=["@container","@id","@language","@reverse","@type"];b.processingMode(e,1.1)&&H.push("@context","@direction","@index","@nest","@prefix","@protected");for(const p in f)if(!H.includes(p))throw new h("Invalid JSON-LD syntax; a term definition must not contain "+p,"jsonld.SyntaxError",{code:"invalid term definition",context:a});const $=s.indexOf(":");if(O._termHasColon=$>0,"@reverse"in f){if("@id"in f)throw new h("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:a});if("@nest"in f)throw new h("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:a});const p=f["@reverse"];if(!r(p))throw new h("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:a});if(p.match(c))return T.eventHandler&&N({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:p}},options:T}),void(v?e.mappings.set(s,v):e.mappings.delete(s));const x=Y(e,p,{vocab:!0,base:!1},a,m,T);if(!n(x))throw new h("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:a});O["@id"]=x,O.reverse=!0}else if("@id"in f){let p=f["@id"];if(p&&!r(p))throw new h("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:a});if(null===p)O["@id"]=null;else{if(!b.isKeyword(p)&&p.match(c))return T.eventHandler&&N({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:p}},options:T}),void(v?e.mappings.set(s,v):e.mappings.delete(s));if(p!==s){if(p=Y(e,p,{vocab:!0,base:!1},a,m,T),!n(p)&&!b.isKeyword(p))throw new h("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:a});if(s.match(/(?::[^:])|\//)&&Y(e,s,{vocab:!0,base:!1},a,new Map(m).set(s,!0),T)!==p)throw new h("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:a});O["@id"]=p,O._prefix=_&&!O._termHasColon&&null!==p.match(/[:\/\?#\[\]@]$/)}}}if(!("@id"in O))if(O._termHasColon){const p=s.substr(0,$);if(a.hasOwnProperty(p)&&b.createTermDefinition({activeCtx:e,localCtx:a,term:p,defined:m,options:T}),e.mappings.has(p)){const x=s.substr($+1);O["@id"]=e.mappings.get(p)["@id"]+x}else O["@id"]=s}else if("@type"===s)O["@id"]=s;else{if(!("@vocab"in e))throw new h("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:a,term:s});O["@id"]=e["@vocab"]+s}if((!0===f["@protected"]||!0===m.get("@protected")&&!1!==f["@protected"])&&(e.protected[s]=!0,O.protected=!0),m.set(s,!0),"@type"in f){let p=f["@type"];if(!r(p))throw new h("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:a});if("@json"===p||"@none"===p){if(b.processingMode(e,1))throw new h(`Invalid JSON-LD syntax; an @context @type value must not be "${p}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:a})}else if("@id"!==p&&"@vocab"!==p){if(p=Y(e,p,{vocab:!0,base:!1},a,m,T),!n(p))throw new h("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:a});if(0===p.indexOf("_:"))throw new h("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:a})}O["@type"]=p}if("@container"in f){const p=r(f["@container"])?[f["@container"]]:f["@container"]||[],x=["@list","@set","@index","@language"];let P=!0;const M=p.includes("@set");if(b.processingMode(e,1.1)){if(x.push("@graph","@id","@type"),p.includes("@list")){if(1!==p.length)throw new h("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:a})}else if(p.includes("@graph")){if(p.some(d=>"@graph"!==d&&"@id"!==d&&"@index"!==d&&"@set"!==d))throw new h("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:a})}else P&=p.length<=(M?2:1);if(p.includes("@type")&&(O["@type"]=O["@type"]||"@id",!["@id","@vocab"].includes(O["@type"])))throw new h("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:a})}else P&=!g(f["@container"]),P&=p.length<=1;if(P&=p.every(d=>x.includes(d)),P&=!(M&&p.includes("@list")),!P)throw new h("Invalid JSON-LD syntax; @context @container value must be one of the following: "+x.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:a});if(O.reverse&&!p.every(d=>["@index","@set"].includes(d)))throw new h("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:a});O["@container"]=p}if("@index"in f){if(!("@container"in f)||!O["@container"].includes("@index"))throw new h(`Invalid JSON-LD syntax; @index without @index in @container: "${f["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:a});if(!r(f["@index"])||0===f["@index"].indexOf("@"))throw new h(`Invalid JSON-LD syntax; @index must expand to an IRI: "${f["@index"]}" on term "${s}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:a});O["@index"]=f["@index"]}if("@context"in f&&(O["@context"]=f["@context"]),"@language"in f&&!("@type"in f)){let p=f["@language"];if(null!==p&&!r(p))throw new h("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:a});null!==p&&(p=p.toLowerCase()),O["@language"]=p}if("@prefix"in f){if(s.match(/:|\//))throw new h("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:a});if(b.isKeyword(O["@id"]))throw new h("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:a});if("boolean"!=typeof f["@prefix"])throw new h("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:a});O._prefix=!0===f["@prefix"]}if("@direction"in f){const p=f["@direction"];if(null!==p&&"ltr"!==p&&"rtl"!==p)throw new h('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:a});O["@direction"]=p}if("@nest"in f){const p=f["@nest"];if(!r(p)||"@nest"!==p&&0===p.indexOf("@"))throw new h("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:a});O["@nest"]=p}const E=O["@id"];if("@context"===E||"@preserve"===E)throw new h("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:a});if(v&&v.protected&&!A&&(e.protected[s]=!0,O.protected=!0,!R(v,O)))throw new h("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:a,term:s})},b.expandIri=(e,a,s,m)=>Y(e,a,s,void 0,void 0,m),b.getInitialContext=e=>{const a=JSON.stringify({processingMode:e.processingMode}),s=o.get(a);if(s)return s;const m={processingMode:e.processingMode,mappings:new Map,inverse:null,getInverse:function T(){const O=this;if(O.inverse)return O.inverse;const H=O.inverse={},$=O.fastCurieMap={},E={},p=(O["@language"]||"@none").toLowerCase(),x=O["@direction"],P=O.mappings,M=[...P.keys()].sort(j);for(const d of M){const G=P.get(d);if(null===G)continue;let Q=G["@container"]||"@none";if(Q=[].concat(Q).sort().join(""),null===G["@id"])continue;const z=l(G["@id"]);for(const K of z){let F=H[K];const V=b.isKeyword(K);if(F)!V&&!G._termHasColon&&E[K].push(d);else if(H[K]=F={},!V&&!G._termHasColon){E[K]=[d];const D={iri:K,terms:E[K]};K[0]in $?$[K[0]].push(D):$[K[0]]=[D]}if(F[Q]||(F[Q]={"@language":{},"@type":{},"@any":{}}),F=F[Q],f(d,F["@any"],"@none"),G.reverse)f(d,F["@type"],"@reverse");else if("@none"===G["@type"])f(d,F["@any"],"@none"),f(d,F["@language"],"@none"),f(d,F["@type"],"@none");else if("@type"in G)f(d,F["@type"],G["@type"]);else if("@language"in G&&"@direction"in G){const D=G["@language"],I=G["@direction"];f(d,F["@language"],D&&I?`${D}_${I}`.toLowerCase():D?D.toLowerCase():I?`_${I}`:"@null")}else"@language"in G?f(d,F["@language"],(G["@language"]||"@null").toLowerCase()):"@direction"in G?f(d,F["@language"],G["@direction"]?`_${G["@direction"]}`:"@none"):x?(f(d,F["@language"],`_${x}`),f(d,F["@language"],"@none"),f(d,F["@type"],"@none")):(f(d,F["@language"],p),f(d,F["@language"],"@none"),f(d,F["@type"],"@none"))}}for(const d in $)A($,d,1);return H},clone:function v(){const O={};return O.mappings=w.clone(this.mappings),O.clone=this.clone,O.inverse=null,O.getInverse=this.getInverse,O.protected=w.clone(this.protected),this.previousContext&&(O.previousContext=this.previousContext.clone()),O.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(O["@base"]=this["@base"]),"@language"in this&&(O["@language"]=this["@language"]),"@vocab"in this&&(O["@vocab"]=this["@vocab"]),O},revertToPreviousContext:function _(){return this.previousContext?this.previousContext.clone():this},protected:{}};return 1e4===o.size&&o.clear(),o.set(a,m),m;function A(O,H,$){const E=O[H],p=O[H]={};let x,P;for(const M of E)x=M.iri,P=$>=x.length?"":x[$],P in p?p[P].push(M):p[P]=[M];for(const M in p)""!==M&&A(p,M,$+1)}function f(O,H,$){H.hasOwnProperty($)||(H[$]=O)}},b.getContextValue=(e,a,s)=>{if(null===a)return"@context"===s?void 0:null;if(e.mappings.has(a)){const m=e.mappings.get(a);if(t(s))return m;if(m.hasOwnProperty(s))return m[s]}return"@language"===s&&s in e||"@direction"===s&&s in e?e[s]:"@context"!==s?null:void 0},b.processingMode=(e,a)=>a.toString()>="1.1"?!e.processingMode||e.processingMode>="json-ld-"+a.toString():"json-ld-1.0"===e.processingMode,b.isKeyword=e=>{if(!r(e)||"@"!==e[0])return!1;switch(e){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1}},3601:(X,Z,u)=>{"use strict";var S=u(4510).default;const{parseLinkHeader:w,buildHeaders:h}=u(6035),{LINK_HEADER_CONTEXT:g}=u(6270),J=u(9027),r=u(7579),{prependBase:t}=u(3834),n=/(^|(\r\n))link:/i;X.exports=({secure:y,headers:N={},xhr:k}={headers:{}})=>{return N=h(N),(new r).wrapLoader(l);function l(o){return j.apply(this,arguments)}function j(){return j=S(function*(o){if(0!==o.indexOf("http:")&&0!==o.indexOf("https:"))throw new J('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:o});if(y&&0!==o.indexOf("https"))throw new J('URL could not be dereferenced; secure mode is enabled and the URL\'s scheme is not "https".',"jsonld.InvalidUrl",{code:"loading document failed",url:o});let L;try{L=yield function i(y,N,k){const c=new(y=y||XMLHttpRequest);return new Promise((l,j)=>{c.onload=()=>l(c),c.onerror=o=>j(o),c.open("GET",N,!0);for(const o in k)c.setRequestHeader(o,k[o]);c.send()})}(k,o,N)}catch(a){throw new J("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:o,cause:a})}if(L.status>=400)throw new J("URL could not be dereferenced: "+L.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:o,httpStatusCode:L.status});let b={contextUrl:null,documentUrl:o,document:L.response},Y=null;const R=L.getResponseHeader("Content-Type");let e;if(n.test(L.getAllResponseHeaders())&&(e=L.getResponseHeader("Link")),e&&"application/ld+json"!==R){const a=w(e),s=a[g];if(Array.isArray(s))throw new J("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:o});s&&(b.contextUrl=s.target),Y=a.alternate,Y&&"application/ld+json"==Y.type&&!(R||"").match(/^application\/(\w*\+)?json$/)&&(b=yield l(t(o,Y.target)))}return b}),j.apply(this,arguments)}}},9802:(X,Z,u)=>{"use strict";const S=u(9027),{isArray:w}=u(9098),{asArray:h}=u(6035),g={};function J({event:t,handlers:n}){let i=!0;for(let y=0;i&&y<n.length;++y){i=!1;const N=n[y];if(w(N))i=J({event:t,handlers:N});else if("function"==typeof N)N({event:t,next:()=>{i=!0}});else{if("object"!=typeof N)throw new S("Invalid event handler.","jsonld.InvalidEventHandler",{event:t});t.code in N?N[t.code]({event:t,next:()=>{i=!0}}):i=!0}}return i}X.exports=g,g.defaultEventHandler=null,g.setupEventHandler=({options:t={}})=>{const n=[].concat(t.safe?g.safeEventHandler:[],t.eventHandler?h(t.eventHandler):[],g.defaultEventHandler?g.defaultEventHandler:[]);return 0===n.length?null:n},g.handleEvent=({event:t,options:n})=>{J({event:t,handlers:n.eventHandler})};const r=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);g.safeEventHandler=function({event:n,next:i}){if("warning"===n.level&&r.has(n.code))throw new S("Safe mode validation error.","jsonld.ValidationError",{event:n});i()},g.logEventHandler=function({event:n,next:i}){console.log(`EVENT: ${n.message}`,{event:n}),i()},g.logWarningEventHandler=function({event:n,next:i}){"warning"===n.level&&console.warn(`WARNING: ${n.message}`,{event:n}),i()},g.unhandledEventHandler=function({event:n}){throw new S("No handler for event.","jsonld.UnhandledEvent",{event:n})},g.setDefaultEventHandler=function({eventHandler:t}={}){g.defaultEventHandler=t?h(t):null}},6551:(X,Z,u)=>{"use strict";var S=u(4510).default;const w=u(9027),{isArray:h,isObject:g,isEmptyObject:J,isString:r,isUndefined:t}=u(9098),{isList:n,isValue:i,isGraph:y,isSubject:N}=u(2926),{expandIri:k,getContextValue:c,isKeyword:l,process:j,processingMode:o}=u(3104),{isAbsolute:L}=u(3834),{REGEX_BCP47:b,REGEX_KEYWORD:Y,addValue:R,asArray:e,getValues:a,validateTypeValue:s}=u(6035),{handleEvent:m}=u(9802),T={};function A({value:E,count:p,options:x}){if(0===p||"@value"in E||"@list"in E||1===p&&"@id"in E){if(x.eventHandler){let P,M;0===p?(P="empty object",M="Dropping empty object."):"@value"in E?(P="object with only @value",M="Dropping object with only @value."):"@list"in E?(P="object with only @list",M="Dropping object with only @list."):1===p&&"@id"in E&&(P="object with only @id",M="Dropping object with only @id."),m({event:{type:["JsonLdEvent"],code:P,level:"warning",message:M,details:{value:E}},options:x})}return null}return E}function f(E){return v.apply(this,arguments)}function v(){return(v=S(function*({activeCtx:E,activeProperty:p,expandedActiveProperty:x,element:P,expandedParent:M,options:d={},insideList:G,typeKey:Q,typeScopedContext:z}){const K=Object.keys(P).sort(),F=[];let V;const D=P[Q]&&"@json"===k(E,h(P[Q])?P[Q][0]:P[Q],{vocab:!0},{...d,typeExpansion:!0});for(const I of K){let W,B=P[I];if("@context"===I)continue;const U=k(E,I,{vocab:!0},d);if(null===U||!L(U)&&!l(U)){d.eventHandler&&m({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:I,expandedProperty:U}},options:d});continue}if(l(U)){if("@reverse"===x)throw new w("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:B});if(U in M&&"@included"!==U&&"@type"!==U)throw new w("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:U})}if("@id"===U){if(!r(B)){if(!d.isFrame)throw new w('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:B});if(g(B)){if(!J(B))throw new w('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:B})}else{if(!h(B))throw new w('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:B});if(!B.every(q=>r(q)))throw new w('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:B})}}R(M,"@id",e(B).map(q=>{if(r(q)){const ne=k(E,q,{base:!0},d);return d.eventHandler&&(null===ne?m(null===q?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:q}},options:d}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:q}},options:d}):L(ne)||m({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:q,expandedId:ne}},options:d})),ne}return q}),{propertyIsArray:d.isFrame});continue}if("@type"===U){g(B)&&(B=Object.fromEntries(Object.entries(B).map(([q,ne])=>[k(z,q,{vocab:!0}),e(ne).map(re=>k(z,re,{base:!0,vocab:!0},{...d,typeExpansion:!0}))]))),s(B,d.isFrame),R(M,"@type",e(B).map(q=>{if(r(q)){const ne=k(z,q,{base:!0,vocab:!0},{...d,typeExpansion:!0});return"@json"!==ne&&!L(ne)&&d.eventHandler&&m({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:q}},options:d}),ne}return q}),{propertyIsArray:!!d.isFrame});continue}if("@included"===U&&o(E,1.1)){const q=e(yield T.expand({activeCtx:E,activeProperty:p,element:B,options:d}));if(!q.every(ne=>N(ne)))throw new w("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:B});R(M,"@included",q,{propertyIsArray:!0});continue}if("@graph"===U&&!g(B)&&!h(B))throw new w('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:B});if("@value"===U){V=B,D&&o(E,1.1)?M["@value"]=B:R(M,"@value",B,{propertyIsArray:d.isFrame});continue}if("@language"===U){if(null===B)continue;if(!r(B)&&!d.isFrame)throw new w('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:B});B=e(B).map(q=>r(q)?q.toLowerCase():q);for(const q of B)r(q)&&!q.match(b)&&d.eventHandler&&m({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:q}},options:d});R(M,"@language",B,{propertyIsArray:d.isFrame});continue}if("@direction"===U){if(!r(B)&&!d.isFrame)throw new w('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:B});B=e(B);for(const q of B)if(r(q)&&"ltr"!==q&&"rtl"!==q)throw new w('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:B});R(M,"@direction",B,{propertyIsArray:d.isFrame});continue}if("@index"===U){if(!r(B))throw new w('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:B});R(M,"@index",B);continue}if("@reverse"===U){if(!g(B))throw new w('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:B});if(W=yield T.expand({activeCtx:E,activeProperty:"@reverse",element:B,options:d}),"@reverse"in W)for(const ne in W["@reverse"])R(M,ne,W["@reverse"][ne],{propertyIsArray:!0});let q=M["@reverse"]||null;for(const ne in W){if("@reverse"===ne)continue;null===q&&(q=M["@reverse"]={}),R(q,ne,[],{propertyIsArray:!0});const re=W[ne];for(let se=0;se<re.length;++se){const ie=re[se];if(i(ie)||n(ie))throw new w('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:W});R(q,ne,ie,{propertyIsArray:!0})}}continue}if("@nest"===U){F.push(I);continue}let C=E;const ee=c(E,I,"@context");t(ee)||(C=yield j({activeCtx:E,localCtx:ee,propagate:!0,overrideProtected:!0,options:d}));const te=c(E,I,"@container")||[];if(te.includes("@language")&&g(B))W=O(C,B,c(C,I,"@direction"),d);else if(te.includes("@index")&&g(B)){const q=te.includes("@graph"),ne=c(C,I,"@index")||"@index",re="@index"!==ne&&k(E,ne,{vocab:!0},d);W=yield H({activeCtx:C,options:d,activeProperty:I,value:B,asGraph:q,indexKey:ne,propertyIndex:re})}else if(te.includes("@id")&&g(B)){const q=te.includes("@graph");W=yield H({activeCtx:C,options:d,activeProperty:I,value:B,asGraph:q,indexKey:"@id"})}else if(te.includes("@type")&&g(B))W=yield H({activeCtx:C.revertToPreviousContext(),options:d,activeProperty:I,value:B,asGraph:!1,indexKey:"@type"});else{const q="@list"===U;if(q||"@set"===U){let ne=p;q&&"@graph"===x&&(ne=null),W=yield T.expand({activeCtx:C,activeProperty:ne,element:B,options:d,insideList:q})}else W="@json"===c(E,I,"@type")?{"@type":"@json","@value":B}:yield T.expand({activeCtx:C,activeProperty:I,element:B,options:d,insideList:!1})}if(null!==W||"@value"===U){if("@list"!==U&&!n(W)&&te.includes("@list")&&(W={"@list":e(W)}),te.includes("@graph")&&!te.some(q=>"@id"===q||"@index"===q)){if(W=e(W),d.isFrame||(W=W.filter(q=>null!==A({value:q,count:Object.keys(q).length,options:d}))),0===W.length)continue;W=W.map(q=>({"@graph":e(q)}))}if(C.mappings.has(I)&&C.mappings.get(I).reverse){const q=M["@reverse"]=M["@reverse"]||{};W=e(W);for(let ne=0;ne<W.length;++ne){const re=W[ne];if(i(re)||n(re))throw new w('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:W});R(q,U,re,{propertyIsArray:!0})}continue}R(M,U,W,{propertyIsArray:!0})}}if("@value"in M&&("@json"!==M["@type"]||!o(E,1.1))&&(g(V)||h(V))&&!d.isFrame)throw new w('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:V});for(const I of F){const B=h(P[I])?P[I]:[P[I]];for(const W of B){if(!g(W)||Object.keys(W).some(U=>"@value"===k(E,U,{vocab:!0},d)))throw new w("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:W});yield f({activeCtx:E,activeProperty:p,expandedActiveProperty:x,element:W,expandedParent:M,options:d,insideList:G,typeScopedContext:z,typeKey:Q})}}})).apply(this,arguments)}function _({activeCtx:E,activeProperty:p,value:x,options:P}){if(null==x)return null;const M=k(E,p,{vocab:!0},P);if("@id"===M)return k(E,x,{base:!0},P);if("@type"===M)return k(E,x,{vocab:!0,base:!0},{...P,typeExpansion:!0});const d=c(E,p,"@type");if(("@id"===d||"@graph"===M)&&r(x)){const Q=k(E,x,{base:!0},P);return null===Q&&x.match(Y)&&P.eventHandler&&m({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:p}},options:P}),{"@id":Q}}if("@vocab"===d&&r(x))return{"@id":k(E,x,{vocab:!0,base:!0},P)};if(l(M))return x;const G={};if(d&&!["@id","@vocab","@none"].includes(d))G["@type"]=d;else if(r(x)){const Q=c(E,p,"@language");null!==Q&&(G["@language"]=Q);const z=c(E,p,"@direction");null!==z&&(G["@direction"]=z)}return["boolean","number","string"].includes(typeof x)||(x=x.toString()),G["@value"]=x,G}function O(E,p,x,P){const M=[],d=Object.keys(p).sort();for(const G of d){const Q=k(E,G,{vocab:!0},P);let z=p[G];h(z)||(z=[z]);for(const K of z){if(null===K)continue;if(!r(K))throw new w("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:p});const F={"@value":K};"@none"!==Q&&(G.match(b)||P.eventHandler&&m({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:G}},options:P}),F["@language"]=G.toLowerCase()),x&&(F["@direction"]=x),M.push(F)}}return M}function H(E){return $.apply(this,arguments)}function $(){return($=S(function*({activeCtx:E,options:p,activeProperty:x,value:P,asGraph:M,indexKey:d,propertyIndex:G}){const Q=[],z=Object.keys(P).sort(),K="@type"===d;for(let F of z){if(K){const I=c(E,F,"@context");t(I)||(E=yield j({activeCtx:E,localCtx:I,propagate:!1,options:p}))}let D,V=P[F];h(V)||(V=[V]),V=yield T.expand({activeCtx:E,activeProperty:x,element:V,options:p,insideList:!1,insideIndex:!0}),D=G?"@none"===F?"@none":_({activeCtx:E,activeProperty:d,value:F,options:p}):k(E,F,{vocab:!0},p),"@id"===d?F=k(E,F,{base:!0},p):K&&(F=D);for(let I of V){if(M&&!y(I)&&(I={"@graph":[I]}),"@type"===d)"@none"===D||(I["@type"]=I["@type"]?[F].concat(I["@type"]):[F]);else{if(i(I)&&!["@language","@type","@index"].includes(d))throw new w(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${d}".`,"jsonld.SyntaxError",{code:"invalid value object",value:I});G?"@none"!==D&&R(I,G,D,{propertyIsArray:!0,prependValue:!0}):"@none"!==D&&!(d in I)&&(I[d]=F)}Q.push(I)}}return Q})).apply(this,arguments)}X.exports=T,T.expand=function(){var E=S(function*({activeCtx:p,activeProperty:x=null,element:P,options:M={},insideList:d=!1,insideIndex:G=!1,typeScopedContext:Q=null}){if(null==P)return null;if("@default"===x&&(M=Object.assign({},M,{isFrame:!1})),!h(P)&&!g(P))return d||null!==x&&"@graph"!==k(p,x,{vocab:!0},M)?_({activeCtx:p,activeProperty:x,value:P,options:M}):(M.eventHandler&&m({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:P}},options:M}),null);if(h(P)){let W=[];const U=c(p,x,"@container")||[];d=d||U.includes("@list");for(let C=0;C<P.length;++C){let ee=yield T.expand({activeCtx:p,activeProperty:x,element:P[C],options:M,insideIndex:G,typeScopedContext:Q});d&&h(ee)&&(ee={"@list":ee}),null!==ee&&(h(ee)?W=W.concat(ee):W.push(ee))}return W}const z=k(p,x,{vocab:!0},M),K=c(p,x,"@context");Q=Q||(p.previousContext?p:null);let F=Object.keys(P).sort(),V=!G;if(V&&Q&&F.length<=2&&!F.includes("@context"))for(const W of F){const U=k(Q,W,{vocab:!0},M);if("@value"===U){V=!1,p=Q;break}if("@id"===U&&1===F.length){V=!1;break}}V&&(p=p.revertToPreviousContext()),t(K)||(p=yield j({activeCtx:p,localCtx:K,propagate:!0,overrideProtected:!0,options:M})),"@context"in P&&(p=yield j({activeCtx:p,localCtx:P["@context"],options:M})),Q=p;let D=null;for(const W of F)if("@type"===k(p,W,{vocab:!0},M)){D=D||W;const C=P[W],ee=Array.isArray(C)?C.length>1?C.slice().sort():C:[C];for(const te of ee){const q=c(Q,te,"@context");t(q)||(p=yield j({activeCtx:p,localCtx:q,options:M,propagate:!1}))}}let I={};yield f({activeCtx:p,activeProperty:x,expandedActiveProperty:z,element:P,expandedParent:I,options:M,insideList:d,typeKey:D,typeScopedContext:Q}),F=Object.keys(I);let B=F.length;if("@value"in I){if("@type"in I&&("@language"in I||"@direction"in I))throw new w('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:I});let W=B-1;if("@type"in I&&(W-=1),"@index"in I&&(W-=1),"@language"in I&&(W-=1),"@direction"in I&&(W-=1),0!==W)throw new w('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:I});const U=null===I["@value"]?[]:e(I["@value"]),C=a(I,"@type");if(!o(p,1.1)||!C.includes("@json")||1!==C.length)if(0===U.length)M.eventHandler&&m({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:I}},options:M}),I=null;else{if(!U.every(ee=>r(ee)||J(ee))&&"@language"in I)throw new w("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:I});if(!C.every(ee=>L(ee)&&!(r(ee)&&0===ee.indexOf("_:"))||J(ee)))throw new w('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:I})}}else if("@type"in I&&!h(I["@type"]))I["@type"]=[I["@type"]];else if("@set"in I||"@list"in I){if(B>1&&(2!==B||!("@index"in I)))throw new w('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:I});"@set"in I&&(I=I["@set"],F=Object.keys(I),B=F.length)}else 1===B&&"@language"in I&&(M.eventHandler&&m({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:I}},options:M}),I=null);return g(I)&&!M.keepFreeFloatingNodes&&!d&&(null===x||"@graph"===z||(c(p,x,"@container")||[]).includes("@graph"))&&(I=A({value:I,count:B,options:M})),I});return function(p){return E.apply(this,arguments)}}()},257:(X,Z,u)=>{"use strict";const{isSubjectReference:S}=u(2926),{createMergedNodeMap:w}=u(253),h={};X.exports=h,h.flatten=g=>{const J=w(g),r=[],t=Object.keys(J).sort();for(let n=0;n<t.length;++n){const i=J[t[n]];S(i)||r.push(i)}return r}},8998:(X,Z,u)=>{"use strict";const{isKeyword:S}=u(3104),w=u(2926),h=u(9098),g=u(6035),J=u(3834),r=u(9027),{createNodeMap:t,mergeNodeMapGraphs:n}=u(253),i={};function y(e){const a={};for(const s in e)void 0!==e[s]&&(a["@"+s]=[e[s]]);return[a]}function N(e,a,s){for(let m=s.length-1;m>=0;--m){const T=s[m];if(T.graph===a&&T.subject["@id"]===e["@id"])return!0}return!1}function k(e,a,s){const m="@"+s;let T=m in e?e[m][0]:a[s];if("embed"===s)if(!0===T)T="@once";else if(!1===T)T="@never";else if("@always"!==T&&"@never"!==T&&"@link"!==T&&"@first"!==T&&"@last"!==T&&"@once"!==T)throw new r("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e});return T}function c(e){if(!h.isArray(e)||1!==e.length||!h.isObject(e[0]))throw new r("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0])for(const a of g.asArray(e[0]["@id"]))if(!h.isObject(a)&&!J.isAbsolute(a)||h.isString(a)&&0===a.indexOf("_:"))throw new r("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e});if("@type"in e[0])for(const a of g.asArray(e[0]["@type"]))if(!h.isObject(a)&&!J.isAbsolute(a)&&"@json"!==a||h.isString(a)&&0===a.indexOf("_:"))throw new r("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}function j(e,a,s,m){let T=!0,A=!1;for(const f in s){let v=!1;const _=g.getValues(a,f),O=0===g.getValues(s,f).length;if("@id"===f){if(h.isEmptyObject(s["@id"][0]||{})?v=!0:s["@id"].length>=0&&(v=s["@id"].includes(_[0])),!m.requireAll)return v}else if("@type"===f){if(T=!1,O){if(_.length>0)return!1;v=!0}else if(1===s["@type"].length&&h.isEmptyObject(s["@type"][0]))v=_.length>0;else for(const H of s["@type"])v=!(!h.isObject(H)||!("@default"in H))||v||_.some($=>$===H);if(!m.requireAll)return v}else{if(S(f))continue;{const H=g.getValues(s,f)[0];let $=!1;if(H&&(c([H]),$="@default"in H),T=!1,0===_.length&&$)continue;if(_.length>0&&O)return!1;if(void 0===H){if(_.length>0)return!1;v=!0}else if(w.isList(H)){const E=H["@list"][0];if(w.isList(_[0])){const p=_[0]["@list"];w.isValue(E)?v=p.some(x=>R(E,x)):(w.isSubject(E)||w.isSubjectReference(E))&&(v=p.some(x=>Y(e,E,x,m)))}}else v=w.isValue(H)?_.some(E=>R(H,E)):w.isSubjectReference(H)?_.some(E=>Y(e,H,E,m)):!!h.isObject(H)&&_.length>0}}if(!v&&m.requireAll)return!1;A=A||v}return T||A}function o(e,a){const s=e.uniqueEmbeds[e.graph],m=s[a],T=m.parent,A=m.property,f={"@id":a};if(h.isArray(T)){for(let _=0;_<T.length;++_)if(g.compareValues(T[_],f)){T[_]=f;break}}else{const _=h.isArray(T[A]);g.removeValue(T,A,f,{propertyIsArray:_}),g.addValue(T,A,f,{propertyIsArray:_})}const v=_=>{const O=Object.keys(s);for(const H of O)H in s&&h.isObject(s[H].parent)&&s[H].parent["@id"]===_&&(delete s[H],v(H))};v(a)}function L(e,a){if(h.isArray(e))return e.map(s=>L(s,a));if(h.isObject(e)){if("@preserve"in e)return e["@preserve"][0];if(w.isValue(e))return e;if(w.isList(e))return e["@list"]=L(e["@list"],a),e;if("@id"in e){const s=e["@id"];if(a.link.hasOwnProperty(s)){const m=a.link[s].indexOf(e);if(-1!==m)return a.link[s][m];a.link[s].push(e)}else a.link[s]=[e]}for(const s in e)"@id"===s&&a.bnodesToClear.includes(e[s])?delete e["@id"]:e[s]=L(e[s],a)}return e}function b(e,a,s){h.isObject(e)?g.addValue(e,a,s,{propertyIsArray:!0}):e.push(s)}function Y(e,a,s,m){if(!("@id"in s))return!1;const T=e.subjects[s["@id"]];return T&&j(e,T,a,m)}function R(e,a){const s=a["@value"],m=a["@type"],T=a["@language"],A=e["@value"]?h.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],f=e["@type"]?h.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],v=e["@language"]?h.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return 0===A.length&&0===f.length&&0===v.length||!(!A.includes(s)&&!h.isEmptyObject(A[0])||!(!m&&0===f.length||f.includes(m)||m&&h.isEmptyObject(f[0]))||!(!T&&0===v.length||v.includes(T)||T&&h.isEmptyObject(v[0])))}X.exports=i,i.frameMergedOrDefault=(e,a,s)=>{const m={options:s,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},T=new g.IdentifierIssuer("_:b");t(e,m.graphMap,"@default",T),s.merged&&(m.graphMap["@merged"]=n(m.graphMap),m.graph="@merged"),m.subjects=m.graphMap[m.graph];const A=[];return i.frame(m,Object.keys(m.subjects).sort(),a,A),s.pruneBlankNodeIdentifiers&&(s.bnodesToClear=Object.keys(m.bnodeMap).filter(f=>1===m.bnodeMap[f].length)),s.link={},L(A,s)},i.frame=(e,a,s,m,T=null)=>{c(s);const A=e.options,f={embed:k(s=s[0],A,"embed"),explicit:k(s,A,"explicit"),requireAll:k(s,A,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const v=e.link[e.graph],_=function l(e,a,s,m){const T={};for(const A of a){const f=e.graphMap[e.graph][A];j(e,f,s,m)&&(T[A]=f)}return T}(e,a,s,f),O=Object.keys(_).sort();for(const H of O){const $=_[H];if(null===T?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},"@link"===f.embed&&H in v){b(m,T,v[H]);continue}const E={"@id":H};if(0===H.indexOf("_:")&&g.addValue(e.bnodeMap,H,E,{propertyIsArray:!0}),v[H]=E,("@first"===f.embed||"@last"===f.embed)&&e.is11)throw new r("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:s});if(e.embedded||!e.uniqueEmbeds[e.graph].hasOwnProperty(H)){if(e.embedded&&("@never"===f.embed||N($,e.graph,e.subjectStack))){b(m,T,E);continue}if(e.embedded&&("@first"==f.embed||"@once"==f.embed)&&e.uniqueEmbeds[e.graph].hasOwnProperty(H)){b(m,T,E);continue}if("@last"===f.embed&&H in e.uniqueEmbeds[e.graph]&&o(e,H),e.uniqueEmbeds[e.graph][H]={parent:m,property:T},e.subjectStack.push({subject:$,graph:e.graph}),H in e.graphMap){let p=!1,x=null;"@graph"in s?(x=s["@graph"][0],p=!("@merged"===H||"@default"===H),h.isObject(x)||(x={})):(p="@merged"!==e.graph,x={}),p&&i.frame({...e,graph:H,embedded:!1},Object.keys(e.graphMap[H]).sort(),[x],E,"@graph")}"@included"in s&&i.frame({...e,embedded:!1},a,s["@included"],E,"@included");for(const p of Object.keys($).sort())if(S(p)){if(E[p]=g.clone($[p]),"@type"===p)for(const x of $["@type"])0===x.indexOf("_:")&&g.addValue(e.bnodeMap,x,E,{propertyIsArray:!0})}else if(!f.explicit||p in s)for(const x of $[p]){const P=p in s?s[p]:y(f);if(w.isList(x)){const M=s[p]&&s[p][0]&&s[p][0]["@list"]?s[p][0]["@list"]:y(f),d={"@list":[]};b(E,p,d);const G=x["@list"];for(const Q of G)w.isSubjectReference(Q)?i.frame({...e,embedded:!0},[Q["@id"]],M,d,"@list"):b(d,"@list",g.clone(Q))}else w.isSubjectReference(x)?i.frame({...e,embedded:!0},[x["@id"]],P,E,p):R(P[0],x)&&b(E,p,g.clone(x))}for(const p of Object.keys(s).sort()){if("@type"===p){if(!h.isObject(s[p][0])||!("@default"in s[p][0]))continue}else if(S(p))continue;const x=s[p][0]||{};if(!k(x,A,"omitDefault")&&!(p in E)){let M="@null";"@default"in x&&(M=g.clone(x["@default"])),h.isArray(M)||(M=[M]),E[p]=[{"@preserve":M}]}}for(const p of Object.keys(s["@reverse"]||{}).sort()){const x=s["@reverse"][p];for(const P of Object.keys(e.subjects))g.getValues(e.subjects[P],p).some(d=>d["@id"]===H)&&(E["@reverse"]=E["@reverse"]||{},g.addValue(E["@reverse"],p,[],{propertyIsArray:!0}),i.frame({...e,embedded:!0},[P],x,E["@reverse"][p],T))}b(m,T,E),e.subjectStack.pop()}}},i.cleanupNull=(e,a)=>{if(h.isArray(e))return e.map(m=>i.cleanupNull(m,a)).filter(m=>m);if("@null"===e)return null;if(h.isObject(e)){if("@id"in e){const s=e["@id"];if(a.link.hasOwnProperty(s)){const m=a.link[s].indexOf(e);if(-1!==m)return a.link[s][m];a.link[s].push(e)}else a.link[s]=[e]}for(const s in e)e[s]=i.cleanupNull(e[s],a)}return e}},6487:(X,Z,u)=>{"use strict";var S=u(4510).default;const w=u(9027),h=u(2926),g=u(9098),{REGEX_BCP47:J,addValue:r}=u(6035),{handleEvent:t}=u(9802),{RDF_LIST:n,RDF_FIRST:i,RDF_REST:y,RDF_NIL:N,RDF_TYPE:k,RDF_JSON_LITERAL:c,XSD_BOOLEAN:l,XSD_DOUBLE:j,XSD_INTEGER:o,XSD_STRING:L}=u(6270),b={};function Y(R,e,a,s){if(R.termType.endsWith("Node"))return{"@id":R.value};const m={"@value":R.value};if(R.language)R.language.match(J)||s.eventHandler&&t({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:R.language}},options:s}),m["@language"]=R.language;else{let T=R.datatype.value;if(T||(T=L),T===c){T="@json";try{m["@value"]=JSON.parse(m["@value"])}catch(A){throw new w("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:m["@value"],cause:A})}}if(e){if(T===l)"true"===m["@value"]?m["@value"]=!0:"false"===m["@value"]&&(m["@value"]=!1);else if(g.isNumeric(m["@value"]))if(T===o){const A=parseInt(m["@value"],10);A.toFixed(0)===m["@value"]&&(m["@value"]=A)}else T===j&&(m["@value"]=parseFloat(m["@value"]));[l,o,j,L].includes(T)||(m["@type"]=T)}else if("i18n-datatype"===a&&T.startsWith("https://www.w3.org/ns/i18n#")){const[,A,f]=T.split(/[#_]/);A.length>0&&(m["@language"]=A,A.match(J)||s.eventHandler&&t({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:A}},options:s})),m["@direction"]=f}else T!==L&&(m["@type"]=T)}return m}X.exports=b,b.fromRDF=function(){var R=S(function*(e,a){const{useRdfType:s=!1,useNativeTypes:m=!1,rdfDirection:T=null}=a,A={},f={"@default":A},v={};if(T){if("compound-literal"===T)throw new w("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:T});if("i18n-datatype"!==T)throw new w("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:T})}for(const H of e){const $="DefaultGraph"===H.graph.termType?"@default":H.graph.value;$ in f||(f[$]={}),"@default"!==$&&!($ in A)&&(A[$]={"@id":$});const E=f[$],p=H.subject.value,x=H.predicate.value,P=H.object;p in E||(E[p]={"@id":p});const M=E[p],d=P.termType.endsWith("Node");if(d&&!(P.value in E)&&(E[P.value]={"@id":P.value}),x===k&&!s&&d){r(M,"@type",P.value,{propertyIsArray:!0});continue}const G=Y(P,m,T,a);if(r(M,x,G,{propertyIsArray:!0}),d)if(P.value===N){const Q=E[P.value];"usages"in Q||(Q.usages=[]),Q.usages.push({node:M,property:x,value:G})}else v[P.value]=!(P.value in v)&&{node:M,property:x,value:G}}for(const H in f){const $=f[H];if(!(N in $))continue;const E=$[N];if(E.usages){for(let p of E.usages){let x=p.node,P=p.property,M=p.value;const d=[],G=[];let Q=Object.keys(x).length;for(;P===y&&g.isObject(v[x["@id"]])&&g.isArray(x[i])&&1===x[i].length&&g.isArray(x[y])&&1===x[y].length&&(3===Q||4===Q&&g.isArray(x["@type"])&&1===x["@type"].length&&x["@type"][0]===n)&&(d.push(x[i][0]),G.push(x["@id"]),p=v[x["@id"]],x=p.node,P=p.property,M=p.value,Q=Object.keys(x).length,h.isBlankNode(x)););delete M["@id"],M["@list"]=d.reverse();for(const z of G)delete $[z]}delete E.usages}}const _=[],O=Object.keys(A).sort();for(const H of O){const $=A[H];if(H in f){const E=$["@graph"]=[],p=f[H],x=Object.keys(p).sort();for(const P of x){const M=p[P];h.isSubjectReference(M)||E.push(M)}}h.isSubjectReference($)||_.push($)}return _});return function(e,a){return R.apply(this,arguments)}}()},2926:(X,Z,u)=>{"use strict";const S=u(9098),w={};X.exports=w,w.isSubject=h=>!(!S.isObject(h)||"@value"in h||"@set"in h||"@list"in h)&&(Object.keys(h).length>1||!("@id"in h)),w.isSubjectReference=h=>S.isObject(h)&&1===Object.keys(h).length&&"@id"in h,w.isValue=h=>S.isObject(h)&&"@value"in h,w.isList=h=>S.isObject(h)&&"@list"in h,w.isGraph=h=>S.isObject(h)&&"@graph"in h&&1===Object.keys(h).filter(g=>"@id"!==g&&"@index"!==g).length,w.isSimpleGraph=h=>w.isGraph(h)&&!("@id"in h),w.isBlankNode=h=>{if(S.isObject(h)){if("@id"in h){const g=h["@id"];return!S.isString(g)||0===g.indexOf("_:")}return 0===Object.keys(h).length||!("@value"in h||"@set"in h||"@list"in h)}return!1}},1045:(X,Z,u)=>{var S=u(4510).default;const w=u(7073),h=u(4577),g=u(6035),J=u(8398),r=g.IdentifierIssuer,t=u(9027),n=u(1983),i=u(6441),{expand:y}=u(6551),{flatten:N}=u(257),{fromRDF:k}=u(6487),{toRDF:c}=u(624),{frameMergedOrDefault:l,cleanupNull:j}=u(8998),{isArray:o,isObject:L,isString:b}=u(9098),{isSubjectReference:Y}=u(2926),{expandIri:R,getInitialContext:e,process:a,processingMode:s}=u(3104),{compact:m,compactIri:T}=u(7374),{createNodeMap:A,createMergedNodeMap:f,mergeNodeMaps:v}=u(253),{logEventHandler:_,logWarningEventHandler:O,safeEventHandler:H,setDefaultEventHandler:$,setupEventHandler:E,strictEventHandler:p,unhandledEventHandler:x}=u(9802),P=function(d){const G={},z=new n({max:100});function K(F,{documentLoader:V=d.documentLoader,...D}){if(F&&"compactionMap"in F)throw new t('"compactionMap" not supported.',"jsonld.OptionsError");if(F&&"expansionMap"in F)throw new t('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:V},D,F,{eventHandler:E({options:F})})}return d.compact=function(){var F=S(function*(V,D,I){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(null===D)throw new t("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(null===V)return null;let B;(I=K(I,{base:b(V)?V:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new r("_:b"),contextResolver:new J({sharedCache:z})})).link&&(I.skipExpansion=!0),I.compactToRelative||delete I.base,B=I.skipExpansion?V:yield d.expand(V,I);const W=yield d.processContext(e(I),D,I);let U=yield m({activeCtx:W,element:B,options:I});I.compactArrays&&!I.graph&&o(U)?1===U.length?U=U[0]:0===U.length&&(U={}):I.graph&&L(U)&&(U=[U]),L(D)&&"@context"in D&&(D=D["@context"]),D=g.clone(D),o(D)||(D=[D]);const C=D;D=[];for(let te=0;te<C.length;++te)(!L(C[te])||Object.keys(C[te]).length>0)&&D.push(C[te]);const ee=D.length>0;if(1===D.length&&(D=D[0]),o(U)){const te=T({activeCtx:W,iri:"@graph",relativeTo:{vocab:!0}}),q=U;U={},ee&&(U["@context"]=D),U[te]=q}else if(L(U)&&ee){const te=U;U={"@context":D};for(const q in te)U[q]=te[q]}return U});return function(V,D,I){return F.apply(this,arguments)}}(),d.expand=function(){var F=S(function*(V,D){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");const I={},B=[];if("expandContext"in(D=K(D,{keepFreeFloatingNodes:!1,contextResolver:new J({sharedCache:z})}))){const ee=g.clone(D.expandContext);I.expandContext=L(ee)&&"@context"in ee?ee:{"@context":ee},B.push(I.expandContext)}let W;if(b(V)){const ee=yield d.get(V,D);W=ee.documentUrl,I.input=ee.document,ee.contextUrl&&(I.remoteContext={"@context":ee.contextUrl},B.push(I.remoteContext))}else I.input=g.clone(V);"base"in D||(D.base=W||"");let U=e(D);for(const ee of B)U=yield a({activeCtx:U,localCtx:ee,options:D});let C=yield y({activeCtx:U,element:I.input,options:D});return L(C)&&"@graph"in C&&1===Object.keys(C).length?C=C["@graph"]:null===C&&(C=[]),o(C)||(C=[C]),C});return function(V,D){return F.apply(this,arguments)}}(),d.flatten=function(){var F=S(function*(V,D,I){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");D="function"==typeof D?null:D||null,I=K(I,{base:b(V)?V:"",contextResolver:new J({sharedCache:z})});const B=yield d.expand(V,I),W=N(B);return null===D?W:(I.graph=!0,I.skipExpansion=!0,yield d.compact(W,D,I))});return function(V,D,I){return F.apply(this,arguments)}}(),d.frame=function(){var F=S(function*(V,D,I){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(I=K(I,{base:b(V)?V:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new J({sharedCache:z})}),b(D)){const re=yield d.get(D,I);if(D=re.document,re.contextUrl){let se=D["@context"];se?o(se)?se.push(re.contextUrl):se=[se,re.contextUrl]:se=re.contextUrl,D["@context"]=se}}const B=D&&D["@context"]||{},W=yield d.processContext(e(I),B,I);I.hasOwnProperty("omitGraph")||(I.omitGraph=s(W,1.1)),I.hasOwnProperty("pruneBlankNodeIdentifiers")||(I.pruneBlankNodeIdentifiers=s(W,1.1));const U=yield d.expand(V,I),C={...I};C.isFrame=!0,C.keepFreeFloatingNodes=!0;const ee=yield d.expand(D,C),te=Object.keys(D).map(re=>R(W,re,{vocab:!0}));C.merged=!te.includes("@graph"),C.is11=s(W,1.1);const q=l(U,ee,C);C.graph=!I.omitGraph,C.skipExpansion=!0,C.link={},C.framing=!0;let ne=yield d.compact(q,B,C);return C.link={},ne=j(ne,C),ne});return function(V,D,I){return F.apply(this,arguments)}}(),d.link=function(){var F=S(function*(V,D,I){const B={};return D&&(B["@context"]=D),B["@embed"]="@link",d.frame(V,B,I)});return function(V,D,I){return F.apply(this,arguments)}}(),d.normalize=d.canonize=function(){var F=S(function*(V,D){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if("inputFormat"in(D=K(D,{base:b(V)?V:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new J({sharedCache:z})}))){if("application/n-quads"!==D.inputFormat&&"application/nquads"!==D.inputFormat)throw new t("Unknown canonicalization input format.","jsonld.CanonizeError");const W=i.parse(V);return w.canonize(W,D)}const I={...D};delete I.format,I.produceGeneralizedRdf=!1;const B=yield d.toRDF(V,I);return w.canonize(B,D)});return function(V,D){return F.apply(this,arguments)}}(),d.fromRDF=function(){var F=S(function*(V,D){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");D=K(D,{format:b(V)?"application/n-quads":void 0});const{format:I}=D;let{rdfParser:B}=D;if(I){if(B=B||G[I],!B)throw new t("Unknown input format.","jsonld.UnknownFormat",{format:I})}else B=()=>V;const W=yield B(V);return k(W,D)});return function(V,D){return F.apply(this,arguments)}}(),d.toRDF=function(){var F=S(function*(V,D){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");let I;I=(D=K(D,{base:b(V)?V:"",skipExpansion:!1,contextResolver:new J({sharedCache:z})})).skipExpansion?V:yield d.expand(V,D);const B=c(I,D);if(D.format){if("application/n-quads"===D.format||"application/nquads"===D.format)return i.serialize(B);throw new t("Unknown output format.","jsonld.UnknownFormat",{format:D.format})}return B});return function(V,D){return F.apply(this,arguments)}}(),d.createNodeMap=function(){var F=S(function*(V,D){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");D=K(D,{base:b(V)?V:"",contextResolver:new J({sharedCache:z})});const I=yield d.expand(V,D);return f(I,D)});return function(V,D){return F.apply(this,arguments)}}(),d.merge=function(){var F=S(function*(V,D,I){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!o(V))throw new TypeError('Could not merge, "docs" must be an array.');D="function"==typeof D?null:D||null,I=K(I,{contextResolver:new J({sharedCache:z})});const B=yield Promise.all(V.map(re=>{const se={...I};return d.expand(re,se)}));let W=!0;"mergeNodes"in I&&(W=I.mergeNodes);const U=I.issuer||new r("_:b"),C={"@default":{}};for(let re=0;re<B.length;++re){const se=g.relabelBlankNodes(B[re],{issuer:new r("_:b"+re+"-")}),ie=W||0===re?C:{"@default":{}};if(A(se,ie,"@default",U),ie!==C)for(const ae in ie){const le=ie[ae];if(!(ae in C)){C[ae]=le;continue}const de=C[ae];for(const ce in le)ce in de||(de[ce]=le[ce])}}const ee=v(C),te=[],q=Object.keys(ee).sort();for(let re=0;re<q.length;++re){const se=ee[q[re]];Y(se)||te.push(se)}return null===D?te:(I.graph=!0,I.skipExpansion=!0,yield d.compact(te,D,I))});return function(V,D,I){return F.apply(this,arguments)}}(),Object.defineProperty(d,"documentLoader",{get:()=>d._documentLoader,set:F=>d._documentLoader=F}),d.documentLoader=function(){var F=S(function*(V){throw new t("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:V})});return function(V){return F.apply(this,arguments)}}(),d.get=function(){var F=S(function*(V,D){let I;I="function"==typeof D.documentLoader?D.documentLoader:d.documentLoader;const B=yield I(V);try{if(!B.document)throw new t("No remote document found at the given URL.","jsonld.NullRemoteDocument");b(B.document)&&(B.document=JSON.parse(B.document))}catch(W){throw new t("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:W,remoteDoc:B})}return B});return function(V,D){return F.apply(this,arguments)}}(),d.processContext=function(){var F=S(function*(V,D,I){return I=K(I,{base:"",contextResolver:new J({sharedCache:z})}),null===D?e(I):(D=g.clone(D),L(D)&&"@context"in D||(D={"@context":D}),a({activeCtx:V,localCtx:D,options:I}))});return function(V,D,I){return F.apply(this,arguments)}}(),d.getContextValue=u(3104).getContextValue,d.documentLoaders={},d.useDocumentLoader=function(F){if(!(F in d.documentLoaders))throw new t('Unknown document loader type: "'+F+'"',"jsonld.UnknownDocumentLoader",{type:F});d.documentLoader=d.documentLoaders[F].apply(d,Array.prototype.slice.call(arguments,1))},d.registerRDFParser=function(F,V){G[F]=V},d.unregisterRDFParser=function(F){delete G[F]},d.registerRDFParser("application/n-quads",i.parse),d.registerRDFParser("application/nquads",i.parse),d.url=u(3834),d.logEventHandler=_,d.logWarningEventHandler=O,d.safeEventHandler=H,d.setDefaultEventHandler=$,d.strictEventHandler=p,d.unhandledEventHandler=x,d.util=g,Object.assign(d,g),d.promises=d,d.RequestQueue=u(7579),d.JsonLdProcessor=u(1985)(d),h.setupGlobals(d),h.setupDocumentLoaders(d),d},M=function(){return P(function(){return M()})};P(M),X.exports=M},253:(X,Z,u)=>{"use strict";const{isKeyword:S}=u(3104),w=u(2926),h=u(9098),g=u(6035),J=u(9027),r={};X.exports=r,r.createMergedNodeMap=(t,n)=>{const i=(n=n||{}).issuer||new g.IdentifierIssuer("_:b"),y={"@default":{}};return r.createNodeMap(t,y,"@default",i),r.mergeNodeMaps(y)},r.createNodeMap=(t,n,i,y,N,k)=>{if(h.isArray(t)){for(const o of t)r.createNodeMap(o,n,i,y,void 0,k);return}if(!h.isObject(t))return void(k&&k.push(t));if(w.isValue(t)){if("@type"in t){let o=t["@type"];0===o.indexOf("_:")&&(t["@type"]=o=y.getId(o))}return void(k&&k.push(t))}if(k&&w.isList(t)){const o=[];return r.createNodeMap(t["@list"],n,i,y,N,o),void k.push({"@list":o})}if("@type"in t){const o=t["@type"];for(const L of o)0===L.indexOf("_:")&&y.getId(L)}h.isUndefined(N)&&(N=w.isBlankNode(t)?y.getId(t["@id"]):t["@id"]),k&&k.push({"@id":N});const c=n[i],l=c[N]=c[N]||{};l["@id"]=N;const j=Object.keys(t).sort();for(let o of j){if("@id"===o)continue;if("@reverse"===o){const b={"@id":N},Y=t["@reverse"];for(const R in Y){const e=Y[R];for(const a of e){let s=a["@id"];w.isBlankNode(a)&&(s=y.getId(s)),r.createNodeMap(a,n,i,y,s),g.addValue(c[s],R,b,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if("@graph"===o){N in n||(n[N]={}),r.createNodeMap(t[o],n,N,y);continue}if("@included"===o){r.createNodeMap(t[o],n,i,y);continue}if("@type"!==o&&S(o)){if("@index"===o&&o in l&&(t[o]!==l[o]||t[o]["@id"]!==l[o]["@id"]))throw new J("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:l});l[o]=t[o];continue}const L=t[o];if(0===o.indexOf("_:")&&(o=y.getId(o)),0!==L.length)for(let b of L)if("@type"===o&&(b=0===b.indexOf("_:")?y.getId(b):b),w.isSubject(b)||w.isSubjectReference(b)){if("@id"in b&&!b["@id"])continue;const Y=w.isBlankNode(b)?y.getId(b["@id"]):b["@id"];g.addValue(l,o,{"@id":Y},{propertyIsArray:!0,allowDuplicate:!1}),r.createNodeMap(b,n,i,y,Y)}else if(w.isValue(b))g.addValue(l,o,b,{propertyIsArray:!0,allowDuplicate:!1});else if(w.isList(b)){const Y=[];r.createNodeMap(b["@list"],n,i,y,N,Y),b={"@list":Y},g.addValue(l,o,b,{propertyIsArray:!0,allowDuplicate:!1})}else r.createNodeMap(b,n,i,y,N),g.addValue(l,o,b,{propertyIsArray:!0,allowDuplicate:!1});else g.addValue(l,o,[],{propertyIsArray:!0})}},r.mergeNodeMapGraphs=t=>{const n={};for(const i of Object.keys(t).sort())for(const y of Object.keys(t[i]).sort()){const N=t[i][y];y in n||(n[y]={"@id":y});const k=n[y];for(const c of Object.keys(N).sort())if(S(c)&&"@type"!==c)k[c]=g.clone(N[c]);else for(const l of N[c])g.addValue(k,c,g.clone(l),{propertyIsArray:!0,allowDuplicate:!1})}return n},r.mergeNodeMaps=t=>{const n=t["@default"],i=Object.keys(t).sort();for(const y of i){if("@default"===y)continue;const N=t[y];let k=n[y];k?"@graph"in k||(k["@graph"]=[]):n[y]=k={"@id":y,"@graph":[]};const c=k["@graph"];for(const l of Object.keys(N).sort()){const j=N[l];w.isSubjectReference(j)||c.push(j)}}return n}},4577:(X,Z,u)=>{"use strict";const S=u(3601),w={};X.exports=w,w.setupDocumentLoaders=function(h){typeof XMLHttpRequest<"u"&&(h.documentLoaders.xhr=S,h.useDocumentLoader("xhr"))},w.setupGlobals=function(h){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:h.JsonLdProcessor})}},624:(X,Z,u)=>{"use strict";const{createNodeMap:S}=u(253),{isKeyword:w}=u(3104),h=u(2926),g=u(8257),J=u(9027),r=u(9098),t=u(6035),{handleEvent:n}=u(9802),{RDF_FIRST:i,RDF_REST:y,RDF_NIL:N,RDF_TYPE:k,RDF_JSON_LITERAL:c,RDF_LANGSTRING:l,XSD_BOOLEAN:j,XSD_DOUBLE:o,XSD_INTEGER:L,XSD_STRING:b}=u(6270),{isAbsolute:Y}=u(3834),R={};function e(m,T,A,f,v){const _=Object.keys(T).sort();for(const O of _){const H=T[O],$=Object.keys(H).sort();for(let E of $){const p=H[E];if("@type"===E)E=k;else if(w(E))continue;for(const x of p){const P={termType:O.startsWith("_:")?"BlankNode":"NamedNode",value:O};if(!Y(O)){v.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:O}},options:v});continue}const M={termType:E.startsWith("_:")?"BlankNode":"NamedNode",value:E};if(!Y(E)){v.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:E}},options:v});continue}if("BlankNode"===M.termType&&!v.produceGeneralizedRdf){v.eventHandler&&n({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:f.getOldIds().find(G=>f.getId(G)===E)}},options:v});continue}const d=s(x,f,m,A,v.rdfDirection,v);d&&m.push({subject:P,predicate:M,object:d,graph:A})}}}}function s(m,T,A,f,v,_){const O={};if(h.isValue(m)){O.termType="Literal",O.value=void 0,O.datatype={termType:"NamedNode"};let H=m["@value"];const $=m["@type"]||null;if("@json"===$)O.value=g(H),O.datatype.value=c;else if(r.isBoolean(H))O.value=H.toString(),O.datatype.value=$||j;else if(r.isDouble(H)||$===o)r.isDouble(H)||(H=parseFloat(H)),O.value=H.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),O.datatype.value=$||o;else if(r.isNumber(H))O.value=H.toFixed(0),O.datatype.value=$||L;else if("@direction"in m&&"i18n-datatype"===v){const E=(m["@language"]||"").toLowerCase();O.datatype.value=`https://www.w3.org/ns/i18n#${E}_${m["@direction"]}`,O.value=H}else{if("@direction"in m&&"compound-literal"===v)throw new J("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:v});if("@direction"in m&&v)throw new J("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:v});"@language"in m?("@direction"in m&&!v&&_.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:O.value}},options:_}),O.value=H,O.datatype.value=$||l,O.language=m["@language"]):("@direction"in m&&!v&&_.eventHandler&&n({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:O.value}},options:_}),O.value=H,O.datatype.value=$||b)}}else if(h.isList(m)){const H=function a(m,T,A,f,v,_){const O={termType:"NamedNode",value:i},H={termType:"NamedNode",value:y},$={termType:"NamedNode",value:N},E=m.pop(),p=E?{termType:"BlankNode",value:T.getId()}:$;let x=p;for(const P of m){const M=s(P,T,A,f,v,_),d={termType:"BlankNode",value:T.getId()};A.push({subject:x,predicate:O,object:M,graph:f}),A.push({subject:x,predicate:H,object:d,graph:f}),x=d}if(E){const P=s(E,T,A,f,v,_);A.push({subject:x,predicate:O,object:P,graph:f}),A.push({subject:x,predicate:H,object:$,graph:f})}return p}(m["@list"],T,A,f,v,_);O.termType=H.termType,O.value=H.value}else{const H=r.isObject(m)?m["@id"]:m;O.termType=H.startsWith("_:")?"BlankNode":"NamedNode",O.value=H}return"NamedNode"!==O.termType||Y(O.value)?O:(_.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:O.value}},options:_}),null)}X.exports=R,R.toRDF=(m,T)=>{const A=new t.IdentifierIssuer("_:b"),f={"@default":{}};S(m,f,"@default",A);const v=[],_=Object.keys(f).sort();for(const O of _){let H;if("@default"===O)H={termType:"DefaultGraph",value:""};else{if(!Y(O)){T.eventHandler&&n({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:O}},options:T});continue}H=O.startsWith("_:")?{termType:"BlankNode"}:{termType:"NamedNode"},H.value=O}e(v,f[O],H,A,T)}return v}},9098:X=>{"use strict";const Z={};X.exports=Z,Z.isArray=Array.isArray,Z.isBoolean=u=>"boolean"==typeof u||"[object Boolean]"===Object.prototype.toString.call(u),Z.isDouble=u=>Z.isNumber(u)&&(-1!==String(u).indexOf(".")||Math.abs(u)>=1e21),Z.isEmptyObject=u=>Z.isObject(u)&&0===Object.keys(u).length,Z.isNumber=u=>"number"==typeof u||"[object Number]"===Object.prototype.toString.call(u),Z.isNumeric=u=>!isNaN(parseFloat(u))&&isFinite(u),Z.isObject=u=>"[object Object]"===Object.prototype.toString.call(u),Z.isString=u=>"string"==typeof u||"[object String]"===Object.prototype.toString.call(u),Z.isUndefined=u=>typeof u>"u"},3834:(X,Z,u)=>{"use strict";const S=u(9098),w={};X.exports=w,w.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}},w.parse=(g,J)=>{const r={},t=w.parsers[J||"full"],n=t.regex.exec(g);let i=t.keys.length;for(;i--;)r[t.keys[i]]=void 0===n[i]?null:n[i];return("https"===r.scheme&&"443"===r.port||"http"===r.scheme&&"80"===r.port)&&(r.href=r.href.replace(":"+r.port,""),r.authority=r.authority.replace(":"+r.port,""),r.port=null),r.normalizedPath=w.removeDotSegments(r.path),r},w.prependBase=(g,J)=>{if(null===g||w.isAbsolute(J))return J;(!g||S.isString(g))&&(g=w.parse(g||""));const r=w.parse(J),t={protocol:g.protocol||""};if(null!==r.authority)t.authority=r.authority,t.path=r.path,t.query=r.query;else if(t.authority=g.authority,""===r.path)t.path=g.path,t.query=null!==r.query?r.query:g.query;else{if(0===r.path.indexOf("/"))t.path=r.path;else{let i=g.path;i=i.substr(0,i.lastIndexOf("/")+1),(i.length>0||g.authority)&&"/"!==i.substr(-1)&&(i+="/"),i+=r.path,t.path=i}t.query=r.query}""!==r.path&&(t.path=w.removeDotSegments(t.path));let n=t.protocol;return null!==t.authority&&(n+="//"+t.authority),n+=t.path,null!==t.query&&(n+="?"+t.query),null!==r.fragment&&(n+="#"+r.fragment),""===n&&(n="./"),n},w.removeBase=(g,J)=>{if(null===g)return J;(!g||S.isString(g))&&(g=w.parse(g||""));let r="";if(""!==g.href?r+=(g.protocol||"")+"//"+(g.authority||""):J.indexOf("//")&&(r+="//"),0!==J.indexOf(r))return J;const t=w.parse(J.substr(r.length)),n=g.normalizedPath.split("/"),i=t.normalizedPath.split("/"),y=t.fragment||t.query?0:1;for(;n.length>0&&i.length>y&&n[0]===i[0];)n.shift(),i.shift();let N="";if(n.length>0){n.pop();for(let k=0;k<n.length;++k)N+="../"}return N+=i.join("/"),null!==t.query&&(N+="?"+t.query),null!==t.fragment&&(N+="#"+t.fragment),""===N&&(N="./"),N},w.removeDotSegments=g=>{if(0===g.length)return"";const J=g.split("/"),r=[];for(;J.length>0;){const t=J.shift(),n=0===J.length;"."!==t?".."!==t?r.push(t):(r.pop(),n&&r.push("")):n&&r.push("")}return"/"===g[0]&&r.length>0&&""!==r[0]&&r.unshift(""),1===r.length&&""===r[0]?"/":r.join("/")};const h=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;w.isAbsolute=g=>S.isString(g)&&h.test(g),w.isRelative=g=>S.isString(g)},6035:(X,Z,u)=>{"use strict";const S=u(2926),w=u(9098),h=u(7073).IdentifierIssuer,g=u(9027),r=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,t=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,n=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,y_headers_accept="application/ld+json, application/json",N={};function k(c,l){if(w.isArray(l))for(let j=0;j<l.length;++j)l[j]=k(c,l[j]);else if(S.isList(l))l["@list"]=k(c,l["@list"]);else if(w.isObject(l)){S.isBlankNode(l)&&(l["@id"]=c.getId(l["@id"]));const j=Object.keys(l).sort();for(let o=0;o<j.length;++o){const L=j[o];"@id"!==L&&(l[L]=k(c,l[L]))}}return l}X.exports=N,N.IdentifierIssuer=h,N.REGEX_BCP47=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,N.REGEX_KEYWORD=/^@[a-zA-Z]+$/,N.clone=function(c){if(c&&"object"==typeof c){let l;if(w.isArray(c)){l=[];for(let j=0;j<c.length;++j)l[j]=N.clone(c[j])}else if(c instanceof Map){l=new Map;for(const[j,o]of c)l.set(j,N.clone(o))}else if(c instanceof Set){l=new Set;for(const j of c)l.add(N.clone(j))}else if(w.isObject(c)){l={};for(const j in c)l[j]=N.clone(c[j])}else l=c.toString();return l}return c},N.asArray=function(c){return Array.isArray(c)?c:[c]},N.buildHeaders=(c={})=>{if(Object.keys(c).some(j=>"accept"===j.toLowerCase()))throw new RangeError('Accept header may not be specified; only "'+y_headers_accept+'" is supported.');return Object.assign({Accept:y_headers_accept},c)},N.parseLinkHeader=c=>{const l={},j=c.match(r);for(let o=0;o<j.length;++o){let L=j[o].match(t);if(!L)continue;const b={target:L[1]},Y=L[2];for(;L=n.exec(Y);)b[L[1]]=void 0===L[2]?L[3]:L[2];const R=b.rel||"";Array.isArray(l[R])?l[R].push(b):l[R]=l.hasOwnProperty(R)?[l[R],b]:b}return l},N.validateTypeValue=(c,l)=>{if(!(w.isString(c)||w.isArray(c)&&c.every(j=>w.isString(j)))){if(l&&w.isObject(c))switch(Object.keys(c).length){case 0:return;case 1:if("@default"in c&&N.asArray(c["@default"]).every(j=>w.isString(j)))return}throw new g('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:c})}},N.hasProperty=(c,l)=>{if(c.hasOwnProperty(l)){const j=c[l];return!w.isArray(j)||j.length>0}return!1},N.hasValue=(c,l,j)=>{if(N.hasProperty(c,l)){let o=c[l];const L=S.isList(o);if(w.isArray(o)||L){L&&(o=o["@list"]);for(let b=0;b<o.length;++b)if(N.compareValues(j,o[b]))return!0}else if(!w.isArray(j))return N.compareValues(j,o)}return!1},N.addValue=(c,l,j,o)=>{if("propertyIsArray"in(o=o||{})||(o.propertyIsArray=!1),"valueIsArray"in o||(o.valueIsArray=!1),"allowDuplicate"in o||(o.allowDuplicate=!0),"prependValue"in o||(o.prependValue=!1),o.valueIsArray)c[l]=j;else if(w.isArray(j)){0===j.length&&o.propertyIsArray&&!c.hasOwnProperty(l)&&(c[l]=[]),o.prependValue&&(j=j.concat(c[l]),c[l]=[]);for(let L=0;L<j.length;++L)N.addValue(c,l,j[L],o)}else if(c.hasOwnProperty(l)){const L=!o.allowDuplicate&&N.hasValue(c,l,j);!w.isArray(c[l])&&(!L||o.propertyIsArray)&&(c[l]=[c[l]]),L||(o.prependValue?c[l].unshift(j):c[l].push(j))}else c[l]=o.propertyIsArray?[j]:j},N.getValues=(c,l)=>[].concat(c[l]||[]),N.removeProperty=(c,l)=>{delete c[l]},N.removeValue=(c,l,j,o)=>{"propertyIsArray"in(o=o||{})||(o.propertyIsArray=!1);const L=N.getValues(c,l).filter(b=>!N.compareValues(b,j));0===L.length?N.removeProperty(c,l):c[l]=1!==L.length||o.propertyIsArray?L:L[0]},N.relabelBlankNodes=(c,l)=>k((l=l||{}).issuer||new h("_:b"),c),N.compareValues=(c,l)=>!!(c===l||S.isValue(c)&&S.isValue(l)&&c["@value"]===l["@value"]&&c["@type"]===l["@type"]&&c["@language"]===l["@language"]&&c["@index"]===l["@index"])||!!(w.isObject(c)&&"@id"in c&&w.isObject(l)&&"@id"in l)&&c["@id"]===l["@id"],N.compareShortestLeast=(c,l)=>c.length<l.length?-1:l.length<c.length?1:c===l?0:c<l?-1:1},1983:(X,Z,u)=>{"use strict";const S=u(513),w=Symbol("max"),h=Symbol("length"),g=Symbol("lengthCalculator"),J=Symbol("allowStale"),r=Symbol("maxAge"),t=Symbol("dispose"),n=Symbol("noDisposeOnSet"),i=Symbol("lruList"),y=Symbol("cache"),N=Symbol("updateAgeOnGet"),k=()=>1,l=(R,e,a)=>{const s=R[y].get(e);if(s){const m=s.value;if(j(R,m)){if(L(R,s),!R[J])return}else a&&(R[N]&&(s.value.now=Date.now()),R[i].unshiftNode(s));return m.value}},j=(R,e)=>{if(!e||!e.maxAge&&!R[r])return!1;const a=Date.now()-e.now;return e.maxAge?a>e.maxAge:R[r]&&a>R[r]},o=R=>{if(R[h]>R[w])for(let e=R[i].tail;R[h]>R[w]&&null!==e;){const a=e.prev;L(R,e),e=a}},L=(R,e)=>{if(e){const a=e.value;R[t]&&R[t](a.key,a.value),R[h]-=a.length,R[y].delete(a.key),R[i].removeNode(e)}};class b{constructor(e,a,s,m,T){this.key=e,this.value=a,this.length=s,this.now=m,this.maxAge=T||0}}const Y=(R,e,a,s)=>{let m=a.value;j(R,m)&&(L(R,a),R[J]||(m=void 0)),m&&e.call(s,m.value,m.key,R)};X.exports=class c{constructor(e){if("number"==typeof e&&(e={max:e}),e||(e={}),e.max&&("number"!=typeof e.max||e.max<0))throw new TypeError("max must be a non-negative number");this[w]=e.max||1/0;const s=e.length||k;if(this[g]="function"!=typeof s?k:s,this[J]=e.stale||!1,e.maxAge&&"number"!=typeof e.maxAge)throw new TypeError("maxAge must be a number");this[r]=e.maxAge||0,this[t]=e.dispose,this[n]=e.noDisposeOnSet||!1,this[N]=e.updateAgeOnGet||!1,this.reset()}set max(e){if("number"!=typeof e||e<0)throw new TypeError("max must be a non-negative number");this[w]=e||1/0,o(this)}get max(){return this[w]}set allowStale(e){this[J]=!!e}get allowStale(){return this[J]}set maxAge(e){if("number"!=typeof e)throw new TypeError("maxAge must be a non-negative number");this[r]=e,o(this)}get maxAge(){return this[r]}set lengthCalculator(e){"function"!=typeof e&&(e=k),e!==this[g]&&(this[g]=e,this[h]=0,this[i].forEach(a=>{a.length=this[g](a.value,a.key),this[h]+=a.length})),o(this)}get lengthCalculator(){return this[g]}get length(){return this[h]}get itemCount(){return this[i].length}rforEach(e,a){a=a||this;for(let s=this[i].tail;null!==s;){const m=s.prev;Y(this,e,s,a),s=m}}forEach(e,a){a=a||this;for(let s=this[i].head;null!==s;){const m=s.next;Y(this,e,s,a),s=m}}keys(){return this[i].toArray().map(e=>e.key)}values(){return this[i].toArray().map(e=>e.value)}reset(){this[t]&&this[i]&&this[i].length&&this[i].forEach(e=>this[t](e.key,e.value)),this[y]=new Map,this[i]=new S,this[h]=0}dump(){return this[i].map(e=>!j(this,e)&&{k:e.key,v:e.value,e:e.now+(e.maxAge||0)}).toArray().filter(e=>e)}dumpLru(){return this[i]}set(e,a,s){if((s=s||this[r])&&"number"!=typeof s)throw new TypeError("maxAge must be a number");const m=s?Date.now():0,T=this[g](a,e);if(this[y].has(e)){if(T>this[w])return L(this,this[y].get(e)),!1;const v=this[y].get(e).value;return this[t]&&(this[n]||this[t](e,v.value)),v.now=m,v.maxAge=s,v.value=a,this[h]+=T-v.length,v.length=T,this.get(e),o(this),!0}const A=new b(e,a,T,m,s);return A.length>this[w]?(this[t]&&this[t](e,a),!1):(this[h]+=A.length,this[i].unshift(A),this[y].set(e,this[i].head),o(this),!0)}has(e){if(!this[y].has(e))return!1;const a=this[y].get(e).value;return!j(this,a)}get(e){return l(this,e,!0)}peek(e){return l(this,e,!1)}pop(){const e=this[i].tail;return e?(L(this,e),e.value):null}del(e){L(this,this[y].get(e))}load(e){this.reset();const a=Date.now();for(let s=e.length-1;s>=0;s--){const m=e[s],T=m.e||0;if(0===T)this.set(m.k,m.v);else{const A=T-a;A>0&&this.set(m.k,m.v,A)}}}prune(){this[y].forEach((e,a)=>l(this,a,!1))}}},969:X=>{"use strict";X.exports=function(Z){Z.prototype[Symbol.iterator]=function*(){for(let u=this.head;u;u=u.next)yield u.value}}},513:(X,Z,u)=>{"use strict";function S(r){var t=this;if(t instanceof S||(t=new S),t.tail=null,t.head=null,t.length=0,r&&"function"==typeof r.forEach)r.forEach(function(y){t.push(y)});else if(arguments.length>0)for(var n=0,i=arguments.length;n<i;n++)t.push(arguments[n]);return t}function w(r,t,n){var i=t===r.head?new J(n,null,t,r):new J(n,t,t.next,r);return null===i.next&&(r.tail=i),null===i.prev&&(r.head=i),r.length++,i}function h(r,t){r.tail=new J(t,r.tail,null,r),r.head||(r.head=r.tail),r.length++}function g(r,t){r.head=new J(t,null,r.head,r),r.tail||(r.tail=r.head),r.length++}function J(r,t,n,i){if(!(this instanceof J))return new J(r,t,n,i);this.list=i,this.value=r,t?(t.next=this,this.prev=t):this.prev=null,n?(n.prev=this,this.next=n):this.next=null}X.exports=S,S.Node=J,S.create=S,S.prototype.removeNode=function(r){if(r.list!==this)throw new Error("removing node which does not belong to this list");var t=r.next,n=r.prev;return t&&(t.prev=n),n&&(n.next=t),r===this.head&&(this.head=t),r===this.tail&&(this.tail=n),r.list.length--,r.next=null,r.prev=null,r.list=null,t},S.prototype.unshiftNode=function(r){if(r!==this.head){r.list&&r.list.removeNode(r);var t=this.head;r.list=this,r.next=t,t&&(t.prev=r),this.head=r,this.tail||(this.tail=r),this.length++}},S.prototype.pushNode=function(r){if(r!==this.tail){r.list&&r.list.removeNode(r);var t=this.tail;r.list=this,r.prev=t,t&&(t.next=r),this.tail=r,this.head||(this.head=r),this.length++}},S.prototype.push=function(){for(var r=0,t=arguments.length;r<t;r++)h(this,arguments[r]);return this.length},S.prototype.unshift=function(){for(var r=0,t=arguments.length;r<t;r++)g(this,arguments[r]);return this.length},S.prototype.pop=function(){if(this.tail){var r=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,r}},S.prototype.shift=function(){if(this.head){var r=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,r}},S.prototype.forEach=function(r,t){t=t||this;for(var n=this.head,i=0;null!==n;i++)r.call(t,n.value,i,this),n=n.next},S.prototype.forEachReverse=function(r,t){t=t||this;for(var n=this.tail,i=this.length-1;null!==n;i--)r.call(t,n.value,i,this),n=n.prev},S.prototype.get=function(r){for(var t=0,n=this.head;null!==n&&t<r;t++)n=n.next;if(t===r&&null!==n)return n.value},S.prototype.getReverse=function(r){for(var t=0,n=this.tail;null!==n&&t<r;t++)n=n.prev;if(t===r&&null!==n)return n.value},S.prototype.map=function(r,t){t=t||this;for(var n=new S,i=this.head;null!==i;)n.push(r.call(t,i.value,this)),i=i.next;return n},S.prototype.mapReverse=function(r,t){t=t||this;for(var n=new S,i=this.tail;null!==i;)n.push(r.call(t,i.value,this)),i=i.prev;return n},S.prototype.reduce=function(r,t){var n,i=this.head;if(arguments.length>1)n=t;else{if(!this.head)throw new TypeError("Reduce of empty list with no initial value");i=this.head.next,n=this.head.value}for(var y=0;null!==i;y++)n=r(n,i.value,y),i=i.next;return n},S.prototype.reduceReverse=function(r,t){var n,i=this.tail;if(arguments.length>1)n=t;else{if(!this.tail)throw new TypeError("Reduce of empty list with no initial value");i=this.tail.prev,n=this.tail.value}for(var y=this.length-1;null!==i;y--)n=r(n,i.value,y),i=i.prev;return n},S.prototype.toArray=function(){for(var r=new Array(this.length),t=0,n=this.head;null!==n;t++)r[t]=n.value,n=n.next;return r},S.prototype.toArrayReverse=function(){for(var r=new Array(this.length),t=0,n=this.tail;null!==n;t++)r[t]=n.value,n=n.prev;return r},S.prototype.slice=function(r,t){(t=t||this.length)<0&&(t+=this.length),(r=r||0)<0&&(r+=this.length);var n=new S;if(t<r||t<0)return n;r<0&&(r=0),t>this.length&&(t=this.length);for(var i=0,y=this.head;null!==y&&i<r;i++)y=y.next;for(;null!==y&&i<t;i++,y=y.next)n.push(y.value);return n},S.prototype.sliceReverse=function(r,t){(t=t||this.length)<0&&(t+=this.length),(r=r||0)<0&&(r+=this.length);var n=new S;if(t<r||t<0)return n;r<0&&(r=0),t>this.length&&(t=this.length);for(var i=this.length,y=this.tail;null!==y&&i>t;i--)y=y.prev;for(;null!==y&&i>r;i--,y=y.prev)n.push(y.value);return n},S.prototype.splice=function(r,t,...n){r>this.length&&(r=this.length-1),r<0&&(r=this.length+r);for(var i=0,y=this.head;null!==y&&i<r;i++)y=y.next;var N=[];for(i=0;y&&i<t;i++)N.push(y.value),y=this.removeNode(y);for(null===y&&(y=this.tail),y!==this.head&&y!==this.tail&&(y=y.prev),i=0;i<n.length;i++)y=w(this,y,n[i]);return N},S.prototype.reverse=function(){for(var r=this.head,t=this.tail,n=r;null!==n;n=n.prev){var i=n.prev;n.prev=n.next,n.next=i}return this.head=t,this.tail=r,this};try{u(969)(S)}catch{}},7073:(X,Z,u)=>{X.exports=u(4793)},3053:X=>{"use strict";X.exports=class ue{constructor(u,S=new Map,w=0){this.prefix=u,this._existing=S,this.counter=w}clone(){const{prefix:u,_existing:S,counter:w}=this;return new ue(u,new Map(S),w)}getId(u){const S=u&&this._existing.get(u);if(S)return S;const w=this.prefix+this.counter;return this.counter++,u&&this._existing.set(u,w),w}hasId(u){return this._existing.has(u)}getOldIds(){return[...this._existing.keys()]}}},4499:(X,Z,u)=>{"use strict";var S=u(4510).default;u(1811);const w=self.crypto||self.msCrypto;X.exports=class{constructor(g){if(!w||!w.subtle)throw new Error("crypto.subtle not found.");if("sha256"===g)this.algorithm={name:"SHA-256"};else{if("sha1"!==g)throw new Error(`Unsupported algorithm "${g}".`);this.algorithm={name:"SHA-1"}}this._content=""}update(g){this._content+=g}digest(){var g=this;return S(function*(){const J=(new TextEncoder).encode(g._content),r=new Uint8Array(yield w.subtle.digest(g.algorithm,J));let t="";for(let n=0;n<r.length;++n)t+=r[n].toString(16).padStart(2,"0");return t})()}}},9511:X=>{"use strict";const S="http://www.w3.org/1999/02/22-rdf-syntax-ns#langString",w="http://www.w3.org/2001/XMLSchema#string",h="NamedNode",g="BlankNode",J="Literal",r="DefaultGraph",t={};function n(c,l){return c.subject.termType===l.subject.termType&&c.object.termType===l.object.termType&&c.subject.value===l.subject.value&&c.predicate.value===l.predicate.value&&c.object.value===l.object.value&&(c.object.termType!==J||c.object.datatype.termType===l.object.datatype.termType&&c.object.language===l.object.language&&c.object.datatype.value===l.object.datatype.value)}(()=>{const c="(?:<([^:]+:[^>]*)>)",j="A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c-\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd_",o=j+"0-9-\xb7\u0300-\u036f\u203f-\u2040",b="(_:(?:["+j+"0-9])(?:(?:["+o+".])*(?:["+o+"]))?)",s="[ \\t]+",m="[ \\t]*",T="(?:"+c+"|"+b+")"+s,A=c+s,f="(?:"+c+"|"+b+'|(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"(?:(?:\\^\\^'+c+")|(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*)))?))"+m,v="(?:\\.|(?:(?:"+c+"|"+b+")"+m+"\\.))";t.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,t.empty=new RegExp("^"+m+"$"),t.quad=new RegExp("^"+m+T+A+f+v+m+"$")})(),X.exports=class oe{static parse(l){const j=[],o={},L=l.split(t.eoln);let b=0;for(const Y of L){if(b++,t.empty.test(Y))continue;const R=Y.match(t.quad);if(null===R)throw new Error("N-Quads parse error on line "+b+".");const e={subject:null,predicate:null,object:null,graph:null};if(e.subject=void 0!==R[1]?{termType:h,value:R[1]}:{termType:g,value:R[2]},e.predicate={termType:h,value:R[3]},void 0!==R[4]?e.object={termType:h,value:R[4]}:void 0!==R[5]?e.object={termType:g,value:R[5]}:(e.object={termType:J,value:void 0,datatype:{termType:h}},void 0!==R[7]?e.object.datatype.value=R[7]:void 0!==R[8]?(e.object.datatype.value=S,e.object.language=R[8]):e.object.datatype.value=w,e.object.value=R[6].replace(N,function(l,j,o,L){if(j)switch(j){case"t":return"\t";case"b":return"\b";case"n":return"\n";case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(o)return String.fromCharCode(parseInt(o,16));if(L)throw new Error("Unsupported U escape")})),e.graph=void 0!==R[9]?{termType:h,value:R[9]}:void 0!==R[10]?{termType:g,value:R[10]}:{termType:r,value:""},e.graph.value in o){let a=!0;const s=o[e.graph.value];for(const m of s)if(n(m,e)){a=!1;break}a&&(s.push(e),j.push(e))}else o[e.graph.value]=[e],j.push(e)}return j}static serialize(l){Array.isArray(l)||(l=oe.legacyDatasetToQuads(l));const j=[];for(const o of l)j.push(oe.serializeQuad(o));return j.sort().join("")}static serializeQuadComponents(l,j,o,L){let b="";return b+=l.termType===h?`<${l.value}>`:`${l.value}`,b+=` <${j.value}> `,o.termType===h?b+=`<${o.value}>`:o.termType===g?b+=o.value:(b+=`"${function y(c){return c.replace(i,function(l){switch(l){case'"':return'\\"';case"\\":return"\\\\";case"\n":return"\\n";case"\r":return"\\r"}})}(o.value)}"`,o.datatype.value===S?o.language&&(b+=`@${o.language}`):o.datatype.value!==w&&(b+=`^^<${o.datatype.value}>`)),L.termType===h?b+=` <${L.value}>`:L.termType===g&&(b+=` ${L.value}`),b+=" .\n",b}static serializeQuad(l){return oe.serializeQuadComponents(l.subject,l.predicate,l.object,l.graph)}static legacyDatasetToQuads(l){const j=[],o={"blank node":g,IRI:h,literal:J};for(const L in l)l[L].forEach(Y=>{const R={};for(const e in Y){const a=Y[e],s={termType:o[a.type],value:a.value};s.termType===J&&(s.datatype={termType:h},"datatype"in a&&(s.datatype.value=a.datatype),"language"in a?("datatype"in a||(s.datatype.value=S),s.language=a.language):"datatype"in a||(s.datatype.value=w)),R[e]=s}R.graph="@default"===L?{termType:r,value:""}:{termType:L.startsWith("_:")?g:h,value:L},j.push(R)});return j}};const i=/["\\\n\r]/g,N=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g},9985:X=>{"use strict";X.exports=class{constructor(u){this.current=u.sort(),this.done=!1,this.dir=new Map;for(let S=0;S<u.length;++S)this.dir.set(u[S],!0)}hasNext(){return!this.done}next(){const{current:u,dir:S}=this,w=u.slice();let h=null,g=0;const J=u.length;for(let r=0;r<J;++r){const t=u[r],n=S.get(t);(null===h||t>h)&&(n&&r>0&&t>u[r-1]||!n&&r<J-1&&t>u[r+1])&&(h=t,g=r)}if(null===h)this.done=!0;else{const r=S.get(h)?g-1:g+1;u[g]=u[r],u[r]=h;for(const t of u)t>h&&S.set(t,!S.get(t))}return w}}},7189:(X,Z,u)=>{"use strict";var S=u(4510).default;const w=u(3053),h=u(4499),g=u(9985),J=u(9511);function r(t,n){return t.hash<n.hash?-1:t.hash>n.hash?1:0}X.exports=class{constructor({createMessageDigest:n=()=>new h("sha256"),canonicalIdMap:i=new Map,maxDeepIterations:y=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new w("_:c14n",i),this.createMessageDigest=n,this.maxDeepIterations=y,this.quads=null,this.deepIterations=null}main(n){var i=this;return S(function*(){i.deepIterations=new Map,i.quads=n;for(const o of n)i._addBlankNodeQuadInfo({quad:o,component:o.subject}),i._addBlankNodeQuadInfo({quad:o,component:o.object}),i._addBlankNodeQuadInfo({quad:o,component:o.graph});const y=new Map,N=[...i.blankNodeInfo.keys()];let k=0;for(const o of N)++k%100==0&&(yield i._yield()),yield i._hashAndTrackBlankNode({id:o,hashToBlankNodes:y});const c=[...y.keys()].sort(),l=[];for(const o of c){const L=y.get(o);L.length>1?l.push(L):i.canonicalIssuer.getId(L[0])}for(const o of l){const L=[];for(const b of o){if(i.canonicalIssuer.hasId(b))continue;const Y=new w("_:b");Y.getId(b);const R=yield i.hashNDegreeQuads(b,Y);L.push(R)}L.sort(r);for(const b of L){const Y=b.issuer.getOldIds();for(const R of Y)i.canonicalIssuer.getId(R)}}const j=[];for(const o of i.quads){const L=J.serializeQuadComponents(i._componentWithCanonicalId(o.subject),o.predicate,i._componentWithCanonicalId(o.object),i._componentWithCanonicalId(o.graph));j.push(L)}return j.sort(),j.join("")})()}hashFirstDegreeQuads(n){var i=this;return S(function*(){const y=[],N=i.blankNodeInfo.get(n),k=N.quads;for(const l of k){const j={subject:null,predicate:l.predicate,object:null,graph:null};j.subject=i.modifyFirstDegreeComponent(n,l.subject,"subject"),j.object=i.modifyFirstDegreeComponent(n,l.object,"object"),j.graph=i.modifyFirstDegreeComponent(n,l.graph,"graph"),y.push(J.serializeQuad(j))}y.sort();const c=i.createMessageDigest();for(const l of y)c.update(l);return N.hash=yield c.digest(),N.hash})()}hashRelatedBlankNode(n,i,y,N){var k=this;return S(function*(){let c;c=k.canonicalIssuer.hasId(n)?k.canonicalIssuer.getId(n):y.hasId(n)?y.getId(n):k.blankNodeInfo.get(n).hash;const l=k.createMessageDigest();return l.update(N),"g"!==N&&l.update(k.getRelatedPredicate(i)),l.update(c),l.digest()})()}hashNDegreeQuads(n,i){var y=this;return S(function*(){const N=y.deepIterations.get(n)||0;if(N>y.maxDeepIterations)throw new Error(`Maximum deep iterations (${y.maxDeepIterations}) exceeded.`);y.deepIterations.set(n,N+1);const k=y.createMessageDigest(),c=yield y.createHashToRelated(n,i),l=[...c.keys()].sort();for(const j of l){k.update(j);let L,o="";const b=new g(c.get(j));let Y=0;for(;b.hasNext();){const R=b.next();++Y%3==0&&(yield y._yield());let e=i.clone(),a="";const s=[];let m=!1;for(const T of R)if(y.canonicalIssuer.hasId(T)?a+=y.canonicalIssuer.getId(T):(e.hasId(T)||s.push(T),a+=e.getId(T)),0!==o.length&&a>o){m=!0;break}if(!m){for(const T of s){const A=yield y.hashNDegreeQuads(T,e);if(a+=e.getId(T),a+=`<${A.hash}>`,e=A.issuer,0!==o.length&&a>o){m=!0;break}}m||(0===o.length||a<o)&&(o=a,L=e)}}k.update(o),i=L}return{hash:yield k.digest(),issuer:i}})()}modifyFirstDegreeComponent(n,i){return"BlankNode"!==i.termType?i:{termType:"BlankNode",value:i.value===n?"_:a":"_:z"}}getRelatedPredicate(n){return`<${n.predicate.value}>`}createHashToRelated(n,i){var y=this;return S(function*(){const N=new Map,k=y.blankNodeInfo.get(n).quads;let c=0;for(const l of k)++c%100==0&&(yield y._yield()),yield Promise.all([y._addRelatedBlankNodeHash({quad:l,component:l.subject,position:"s",id:n,issuer:i,hashToRelated:N}),y._addRelatedBlankNodeHash({quad:l,component:l.object,position:"o",id:n,issuer:i,hashToRelated:N}),y._addRelatedBlankNodeHash({quad:l,component:l.graph,position:"g",id:n,issuer:i,hashToRelated:N})]);return N})()}_hashAndTrackBlankNode(n){var i=this;return S(function*({id:y,hashToBlankNodes:N}){const k=yield i.hashFirstDegreeQuads(y),c=N.get(k);c?c.push(y):N.set(k,[y])}).apply(this,arguments)}_addBlankNodeQuadInfo({quad:n,component:i}){if("BlankNode"!==i.termType)return;const y=i.value,N=this.blankNodeInfo.get(y);N?N.quads.add(n):this.blankNodeInfo.set(y,{quads:new Set([n]),hash:null})}_addRelatedBlankNodeHash(n){var i=this;return S(function*({quad:y,component:N,position:k,id:c,issuer:l,hashToRelated:j}){if("BlankNode"!==N.termType||N.value===c)return;const o=N.value,L=yield i.hashRelatedBlankNode(o,y,l,k),b=j.get(L);b?b.push(o):j.set(L,[o])}).apply(this,arguments)}_componentWithCanonicalId(n){return"BlankNode"!==n.termType||n.value.startsWith(this.canonicalIssuer.prefix)?n:{termType:"BlankNode",value:this.canonicalIssuer.getId(n.value)}}_yield(){return S(function*(){return new Promise(n=>setImmediate(n))})()}}},5930:(X,Z,u)=>{"use strict";const S=u(3053),w=u(4499),h=u(9985),g=u(9511);function J(r,t){return r.hash<t.hash?-1:r.hash>t.hash?1:0}X.exports=class{constructor({createMessageDigest:t=()=>new w("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:i=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new S("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=i,this.quads=null,this.deepIterations=null}main(t){this.deepIterations=new Map,this.quads=t;for(const c of t)this._addBlankNodeQuadInfo({quad:c,component:c.subject}),this._addBlankNodeQuadInfo({quad:c,component:c.object}),this._addBlankNodeQuadInfo({quad:c,component:c.graph});const n=new Map,i=[...this.blankNodeInfo.keys()];for(const c of i)this._hashAndTrackBlankNode({id:c,hashToBlankNodes:n});const y=[...n.keys()].sort(),N=[];for(const c of y){const l=n.get(c);l.length>1?N.push(l):this.canonicalIssuer.getId(l[0])}for(const c of N){const l=[];for(const j of c){if(this.canonicalIssuer.hasId(j))continue;const o=new S("_:b");o.getId(j);const L=this.hashNDegreeQuads(j,o);l.push(L)}l.sort(J);for(const j of l){const o=j.issuer.getOldIds();for(const L of o)this.canonicalIssuer.getId(L)}}const k=[];for(const c of this.quads){const l=g.serializeQuadComponents(this._componentWithCanonicalId({component:c.subject}),c.predicate,this._componentWithCanonicalId({component:c.object}),this._componentWithCanonicalId({component:c.graph}));k.push(l)}return k.sort(),k.join("")}hashFirstDegreeQuads(t){const n=[],i=this.blankNodeInfo.get(t),y=i.quads;for(const k of y){const c={subject:null,predicate:k.predicate,object:null,graph:null};c.subject=this.modifyFirstDegreeComponent(t,k.subject,"subject"),c.object=this.modifyFirstDegreeComponent(t,k.object,"object"),c.graph=this.modifyFirstDegreeComponent(t,k.graph,"graph"),n.push(g.serializeQuad(c))}n.sort();const N=this.createMessageDigest();for(const k of n)N.update(k);return i.hash=N.digest(),i.hash}hashRelatedBlankNode(t,n,i,y){let N;N=this.canonicalIssuer.hasId(t)?this.canonicalIssuer.getId(t):i.hasId(t)?i.getId(t):this.blankNodeInfo.get(t).hash;const k=this.createMessageDigest();return k.update(y),"g"!==y&&k.update(this.getRelatedPredicate(n)),k.update(N),k.digest()}hashNDegreeQuads(t,n){const i=this.deepIterations.get(t)||0;if(i>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,i+1);const y=this.createMessageDigest(),N=this.createHashToRelated(t,n),k=[...N.keys()].sort();for(const c of k){y.update(c);let j,l="";const o=new h(N.get(c));for(;o.hasNext();){const L=o.next();let b=n.clone(),Y="";const R=[];let e=!1;for(const a of L)if(this.canonicalIssuer.hasId(a)?Y+=this.canonicalIssuer.getId(a):(b.hasId(a)||R.push(a),Y+=b.getId(a)),0!==l.length&&Y>l){e=!0;break}if(!e){for(const a of R){const s=this.hashNDegreeQuads(a,b);if(Y+=b.getId(a),Y+=`<${s.hash}>`,b=s.issuer,0!==l.length&&Y>l){e=!0;break}}e||(0===l.length||Y<l)&&(l=Y,j=b)}}y.update(l),n=j}return{hash:y.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return"BlankNode"!==n.termType?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}createHashToRelated(t,n){const i=new Map,y=this.blankNodeInfo.get(t).quads;for(const N of y)this._addRelatedBlankNodeHash({quad:N,component:N.subject,position:"s",id:t,issuer:n,hashToRelated:i}),this._addRelatedBlankNodeHash({quad:N,component:N.object,position:"o",id:t,issuer:n,hashToRelated:i}),this._addRelatedBlankNodeHash({quad:N,component:N.graph,position:"g",id:t,issuer:n,hashToRelated:i});return i}_hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const i=this.hashFirstDegreeQuads(t),y=n.get(i);y?y.push(t):n.set(i,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if("BlankNode"!==n.termType)return;const i=n.value,y=this.blankNodeInfo.get(i);y?y.quads.add(t):this.blankNodeInfo.set(i,{quads:new Set([t]),hash:null})}_addRelatedBlankNodeHash({quad:t,component:n,position:i,id:y,issuer:N,hashToRelated:k}){if("BlankNode"!==n.termType||n.value===y)return;const c=n.value,l=this.hashRelatedBlankNode(c,t,N,i),j=k.get(l);j?j.push(c):k.set(l,[c])}_componentWithCanonicalId({component:t}){return"BlankNode"!==t.termType||t.value.startsWith(this.canonicalIssuer.prefix)?t:{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}}}},393:(X,Z,u)=>{"use strict";var S=u(4510).default;const w=u(4499),h=u(7189);X.exports=class extends h{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new w("sha1")}modifyFirstDegreeComponent(J,r,t){return"BlankNode"!==r.termType?r:"graph"===t?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:r.value===J?"_:a":"_:z"}}getRelatedPredicate(J){return J.predicate.value}createHashToRelated(J,r){var t=this;return S(function*(){const n=new Map,i=t.blankNodeInfo.get(J).quads;let y=0;for(const N of i){let k,c;if("BlankNode"===N.subject.termType&&N.subject.value!==J)c=N.subject.value,k="p";else{if("BlankNode"!==N.object.termType||N.object.value===J)continue;c=N.object.value,k="r"}++y%100==0&&(yield t._yield());const l=yield t.hashRelatedBlankNode(c,N,r,k),j=n.get(l);j?j.push(c):n.set(l,[c])}return n})()}}},1382:(X,Z,u)=>{"use strict";const S=u(4499),w=u(5930);X.exports=class extends w{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new S("sha1")}modifyFirstDegreeComponent(g,J,r){return"BlankNode"!==J.termType?J:"graph"===r?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:J.value===g?"_:a":"_:z"}}getRelatedPredicate(g){return g.predicate.value}createHashToRelated(g,J){const r=new Map,t=this.blankNodeInfo.get(g).quads;for(const n of t){let i,y;if("BlankNode"===n.subject.termType&&n.subject.value!==g)y=n.subject.value,i="p";else{if("BlankNode"!==n.object.termType||n.object.value===g)continue;y=n.object.value,i="r"}const N=this.hashRelatedBlankNode(y,n,J,i),k=r.get(N);k?k.push(y):r.set(N,[y])}return r}}},4793:(X,Z,u)=>{"use strict";var S=u(4510).default;const w=u(7189),h=u(393),g=u(5930),J=u(1382);let r;try{r=u(7789)}catch{}function t(n){return Array.isArray(n)?n:Z.NQuads.legacyDatasetToQuads(n)}Z.NQuads=u(9511),Z.IdentifierIssuer=u(3053),Z._rdfCanonizeNative=function(n){return n&&(r=n),r},Z.canonize=function(){var n=S(function*(i,y){const N=t(i);if(y.useNative){if(!r)throw new Error("rdf-canonize-native not available");if(y.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((k,c)=>r.canonize(N,y,(l,j)=>l?c(l):k(j)))}if("URDNA2015"===y.algorithm)return new w(y).main(N);if("URGNA2012"===y.algorithm){if(y.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new h(y).main(N)}throw"algorithm"in y?new Error("Invalid RDF Dataset Canonicalization algorithm: "+y.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")});return function(i,y){return n.apply(this,arguments)}}(),Z._canonizeSync=function(n,i){const y=t(n);if(i.useNative){if(!r)throw new Error("rdf-canonize-native not available");if(i.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return r.canonizeSync(y,i)}if("URDNA2015"===i.algorithm)return new g(i).main(y);if("URGNA2012"===i.algorithm){if(i.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new J(i).main(y)}throw"algorithm"in i?new Error("Invalid RDF Dataset Canonicalization algorithm: "+i.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}},1811:function(){!function(X){"use strict";if(!X.setImmediate){var g,u=1,S={},w=!1,h=X.document,j=Object.getPrototypeOf&&Object.getPrototypeOf(X);j=j&&j.setTimeout?j:X,"[object process]"==={}.toString.call(X.process)?function i(){g=function(o){process.nextTick(function(){n(o)})}}():function y(){if(X.postMessage&&!X.importScripts){var o=!0,L=X.onmessage;return X.onmessage=function(){o=!1},X.postMessage("","*"),X.onmessage=L,o}}()?function N(){var o="setImmediate$"+Math.random()+"$",L=function(b){b.source===X&&"string"==typeof b.data&&0===b.data.indexOf(o)&&n(+b.data.slice(o.length))};X.addEventListener?X.addEventListener("message",L,!1):X.attachEvent("onmessage",L),g=function(b){X.postMessage(o+b,"*")}}():X.MessageChannel?function k(){var o=new MessageChannel;o.port1.onmessage=function(L){n(L.data)},g=function(L){o.port2.postMessage(L)}}():h&&"onreadystatechange"in h.createElement("script")?function c(){var o=h.documentElement;g=function(L){var b=h.createElement("script");b.onreadystatechange=function(){n(L),b.onreadystatechange=null,o.removeChild(b),b=null},o.appendChild(b)}}():function l(){g=function(o){setTimeout(n,0,o)}}(),j.setImmediate=function J(o){"function"!=typeof o&&(o=new Function(""+o));for(var L=new Array(arguments.length-1),b=0;b<L.length;b++)L[b]=arguments[b+1];return S[u]={callback:o,args:L},g(u),u++},j.clearImmediate=r}function r(o){delete S[o]}function n(o){if(w)setTimeout(n,0,o);else{var L=S[o];if(L){w=!0;try{!function t(o){var L=o.callback,b=o.args;switch(b.length){case 0:L();break;case 1:L(b[0]);break;case 2:L(b[0],b[1]);break;case 3:L(b[0],b[1],b[2]);break;default:L.apply(undefined,b)}}(L)}finally{r(o),w=!1}}}}}(typeof self>"u"?typeof global>"u"?this:global:self)},7789:()=>{},4510:X=>{function Z(S,w,h,g,J,r,t){try{var n=S[r](t),i=n.value}catch(y){return void h(y)}n.done?w(i):Promise.resolve(i).then(g,J)}X.exports=function u(S){return function(){var w=this,h=arguments;return new Promise(function(g,J){var r=S.apply(w,h);function t(i){Z(r,g,J,t,n,"next",i)}function n(i){Z(r,g,J,t,n,"throw",i)}t(void 0)})}},X.exports.__esModule=!0,X.exports.default=X.exports}}]);